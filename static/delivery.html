<!DOCTYPE html>
<html lang="kz">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Delivery</title>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- Yandex Maps v3 -->
  <script defer src="https://api-maps.yandex.ru/v3/?apikey=8a3e4da0-9ef2-4176-9203-e7014c1dba6f&lang=ru_RU"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      height: 100vh;
      height: 100dvh;
      overflow: hidden;
      background: #f8f9fa;
      position: fixed;
      width: 100%;
    }
    #map {
      height: 100vh;
      height: 100dvh;
      width: 100vw;
      position: fixed;
      top: 0;
      left: 0;
    }

    /* FIXED: Remove touch-action override to allow map gestures */
    #map, #pickerMap {
      touch-action: none;
      -ms-touch-action: none;
      -webkit-touch-action: none;
    }

    /* Top Controls */
    .top-bar {
      position: fixed;
      top: env(safe-area-inset-top, 12px);
      left: 12px;
      right: 12px;
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      pointer-events: none;
    }
    .gps-status, .lang-switch {
      pointer-events: auto;
    }

    .gps-status {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      padding: 10px 14px;
      border-radius: 18px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      font-size: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }
    .gps-dot {
      width: 6px;
      height: 6px;
      background: #10b981;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    .gps-dot.error {
      background: #ef4444;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    .lang-switch {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 18px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      display: flex;
      padding: 2px;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }
    .lang-btn {
      padding: 6px 12px;
      border: none;
      background: none;
      border-radius: 16px;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      color: #6b7280;
    }
    .lang-btn.active {
      background: #000;
      color: white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    /* CENTER PIN */
    .center-pin {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -100%);
      z-index: 999;
      pointer-events: none;
      display: none;
    }
    .center-pin.active {
      display: block;
      animation: pinDrop 0.3s ease-out;
    }
    
    /* FIXED: Separate picker pin class */
    .picker-center-pin {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -100%);
      z-index: 999;
      pointer-events: none;
      display: block;
      animation: pinDrop 0.3s ease-out;
    }
    
    @keyframes pinDrop {
      0% { transform: translate(-50%, -150%) scale(0.8); opacity: 0; }
      70% { transform: translate(-50%, -95%) scale(1.05); opacity: 1; }
      100% { transform: translate(-50%, -100%) scale(1); opacity: 1; }
    }
    .pin-icon {
      width: 20px;
      height: 20px;
      background: #000;
      border-radius: 50% 50% 50% 0;
      transform: rotate(-45deg);
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);
      position: relative;
      border: 2px solid #fff;
    }
    .pin-icon::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      width: 4px;
      height: 4px;
      background: white;
      border-radius: 50%;
    }

    /* Bottom sheet */
    .bottom-sheet {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      border-radius: 24px 24px 0 0;
      box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.12);
      z-index: 1001;
      height: auto;
      min-height: 45vh;
      max-height: 85vh;
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      display: flex;
      flex-direction: column;
    }
    .sheet-handle {
      width: 36px;
      height: 4px;
      background: #d1d5db;
      border-radius: 2px;
      margin: 8px auto 6px;
      flex-shrink: 0;
    }
    .sheet-content {
      flex: 1;
      padding: 0 16px 16px;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .step-indicator {
      display: flex;
      justify-content: center;
      gap: 6px;
      margin-bottom: 16px;
      padding: 0;
      flex-shrink: 0;
    }
    .step-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #e5e7eb;
      transition: all 0.3s ease;
    }
    .step-dot.active {
      background: #000;
      transform: scale(1.3);
    }

    .address-section {
      flex-shrink: 0;
      margin-bottom: 16px;
    }
    .address-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 12px;
      background: #f8f9fa;
      border-radius: 16px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
      position: relative;
      overflow: hidden;
      min-height: 56px;
    }
    .address-card:active { transform: scale(0.98); }
    .address-card.filled {
      background: linear-gradient(135deg, #f0fdf4, #dcfce7);
      border-color: #10b981;
    }
    .address-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, #10b981, #059669);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }
    .address-card.filled::before { transform: scaleX(1); }

    /* FIXED: High specificity marker styles */
    .marker {
      width: 32px !important;
      height: 32px !important;
      border-radius: 50% !important;
      background: #000 !important;
      color: white !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      font-weight: 700 !important;
      font-size: 14px !important;
      flex-shrink: 0 !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
    }
    .marker.dropoff {
      background: linear-gradient(135deg, #ef4444, #dc2626) !important;
    }
    .address-text {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .address-label {
      font-size: 11px;
      color: #6b7280;
      margin: 0;
      font-weight: 600;
      letter-spacing: 0.3px;
      line-height: 1;
    }
    .address-value {
      font-size: 14px;
      font-weight: 600;
      line-height: 1.1;
      color: #111827;
      margin-top: 3px;
      margin-bottom: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .route-info {
      padding: 12px;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      border-radius: 14px;
      margin: 8px 0;
      text-align: center;
      font-size: 12px;
      font-weight: 600;
      display: none;
      box-shadow: 0 4px 16px rgba(16, 185, 129, 0.3);
      flex-shrink: 0;
    }
    .route-info.active {
      display: block;
      animation: slideUp 0.4s ease;
    }
    @keyframes slideUp {
      from { opacity: 0; transform: translateY(16px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .form-step {
      display: none;
      flex: 1;
      flex-direction: column;
      min-height: 0;
    }
    .form-step.active { display: flex; }
    .form-title {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 16px;
      color: #111827;
      flex-shrink: 0;
    }
    .form-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .form-grid {
      display: grid;
      gap: 10px;
      margin-bottom: 16px;
      flex-shrink: 0;
    }
    .form-grid.two-col { grid-template-columns: 1fr 1fr; }

    .form-field {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 12px;
      border: 2px solid transparent;
      transition: all 0.2s ease;
    }
    .form-field:focus-within {
      border-color: #10b981;
      background: white;
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.08);
    }

    .field-label {
      font-size: 10px;
      color: #6b7280;
      margin-bottom: 6px;
      font-weight: 600;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .field-input {
      width: 100%;
      border: none;
      background: none;
      font-size: 14px;
      font-weight: 500;
      outline: none;
      color: #111827;
    }
    .field-input::placeholder { color: #9ca3af; }
    textarea.field-input {
      min-height: 48px;
      resize: none;
      font-family: inherit;
      line-height: 1.3;
    }

    .truck-section {
      flex-shrink: 0;
      margin-bottom: 16px;
    }
    .truck-label {
      font-size: 10px;
      color: #6b7280;
      margin-bottom: 10px;
      font-weight: 600;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .truck-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 8px;
  margin-bottom: 16px;
}


    .truck-option {
      padding: 10px;
      background: #f8f9fa;
      border-radius: 12px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }
    .truck-option:active { transform: scale(0.96); }
    .truck-option.selected {
  border-color: #10b981;
  background: linear-gradient(135deg, #f0fdf4, #dcfce7);
  box-shadow: 0 6px 20px rgba(16,185,129,.25);
  transform: translateY(-1px);
}
    .truck-icon {
      font-size: 16px;
      margin-bottom: 4px;
    }
    .truck-name {
      font-size: 11px;
      font-weight: 600;
      color: #111827;
      margin-bottom: 2px;
    }
    .truck-desc {
      font-size: 9px;
      color: #6b7280;
    }

    .btn {
      width: 100%;
      padding: 14px;
      border: none;
      border-radius: 14px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      position: relative;
      overflow: hidden;
    }
    .btn-primary {
      background: linear-gradient(135deg, #000, #1f2937);
      color: white;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }
    .btn-primary:active {
      transform: scale(0.96);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    .btn-primary:disabled {
      background: #d1d5db;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .btn-secondary {
      background: #f3f4f6;
      color: #374151;
      border: 1px solid #e5e7eb;
    }
    .btn-secondary:active {
      background: #e5e7eb;
      transform: scale(0.96);
    }

    .button-grid {
      display: grid;
      gap: 10px;
      flex-shrink: 0;
      margin-top: 16px;
    }
    .button-grid.single { grid-template-columns: 1fr; }
    .button-grid.double { grid-template-columns: 1fr 1fr; }

    /* Success Screen */
    .success-screen {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      padding: 20px;
    }
    .success-screen.active {
      display: flex;
      animation: successSlideIn 0.5s ease-out;
    }
    @keyframes successSlideIn {
      from { opacity: 0; transform: translateY(100%); }
      to { opacity: 1; transform: translateY(0); }
    }
    .success-icon {
      font-size: 72px;
      margin-bottom: 20px;
      animation: successPulse 2s infinite;
    }
    @keyframes successPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .success-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 12px;
    }
    .success-message {
      font-size: 16px;
      opacity: 0.9;
      margin-bottom: 24px;
      line-height: 1.4;
    }
    .success-btn {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      padding: 12px 24px;
      border-radius: 14px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .success-btn:active {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(0.96);
    }

    /* Picker Modal */
    .picker-modal {
      position: fixed;
      inset: 0;
      background: white;
      z-index: 2000;
      display: none;
    }
    .picker-modal.active {
      display: block;
      animation: slideInUp 0.3s ease;
    }
    @keyframes slideInUp {
      from { transform: translateY(100%); }
      to { transform: translateY(0); }
    }
    .picker-header {
      position: fixed;
      top: env(safe-area-inset-top, 12px);
      left: 12px;
      right: 12px;
      z-index: 2001;
      display: flex;
      gap: 10px;
    }
    .back-btn {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: none;
      border-radius: 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      flex-shrink: 0;
      transition: all 0.2s ease;
      font-size: 16px;
      font-weight: 600;
    }
    .back-btn:active { transform: scale(0.94); }
    .search-box {
      flex: 1;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: none;
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      font-size: 14px;
      outline: none;
      font-weight: 500;
    }
    #pickerMap {
      height: 100vh;
      height: 100dvh;
      width: 100vw;
    }
    .address-bar {
      position: fixed;
      top: 68px;
      left: 12px;
      right: 12px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      padding: 12px;
      border-radius: 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      font-size: 12px;
      font-weight: 500;
      z-index: 2001;
      display: block;
      line-height: 1.3;
      min-height: 44px;
      display: flex;
      align-items: center;
    }
    .confirm-btn {
      position: fixed;
      bottom: env(safe-area-inset-bottom, 16px);
      left: 12px;
      right: 12px;
      z-index: 2010;
      pointer-events: auto; /* FIXED: Ensure button is clickable */
    }

    /* FIXED: Suggestions z-index below confirm button */
    .suggestions {
      position: fixed;
      top: 120px;
      left: 12px;
      right: 12px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 14px;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
      max-height: 40vh;
      overflow-y: auto;
      z-index: 2005;
      display: none;
    }
    .suggestions.active { display: block; }
    .suggestion-item {
      padding: 12px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.04);
      cursor: pointer;
      transition: background 0.2s ease;
      font-size: 13px;
    }
    .suggestion-item:active { background: rgba(0, 0, 0, 0.03); }
    .suggestion-item:last-child { border-bottom: none; }

    /* FIXED: High specificity HTML-based markers */
    .user-marker {
      width: 14px !important;
      height: 14px !important;
      background: #3b82f6 !important;
      border: 3px solid white !important;
      border-radius: 50% !important;
      box-shadow: 0 3px 12px rgba(59, 130, 246, 0.4) !important;
      position: relative !important;
      animation: userPulse 2s infinite !important;
    }
    .user-marker::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 6px;
      height: 6px;
      background: white;
      border-radius: 50%;
    }

    @keyframes userPulse {
      0%, 100% { transform: scale(1); box-shadow: 0 3px 12px rgba(59, 130, 246, 0.4); }
      50% { transform: scale(1.1); box-shadow: 0 3px 20px rgba(59, 130, 246, 0.6); }
    }

    .custom-marker {
      width: 24px !important;
      height: 24px !important;
      border-radius: 50% !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      font-weight: 700 !important;
      color: white !important;
      font-size: 12px !important;
      border: 2px solid white !important;
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.25) !important;
      animation: markerBounce 0.6s ease-out !important;
    }
    .custom-marker.pickup {
      background: linear-gradient(135deg, #000, #374151) !important;
    }
    .custom-marker.dropoff {
      background: linear-gradient(135deg, #ef4444, #dc2626) !important;
    }

    @keyframes markerBounce {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    @media (max-height: 700px) {
      .bottom-sheet { min-height: 48vh; max-height: 82vh; }
      .truck-grid { grid-template-columns: repeat(4, 1fr); gap: 6px; }
      .truck-option { padding: 8px 4px; }
      .truck-name { font-size: 10px; }
      .truck-desc { font-size: 8px; }
    }
    @media (max-height: 600px) {
      .bottom-sheet { min-height: 52vh; max-height: 85vh; }
      .form-grid.two-col { grid-template-columns: 1fr; }
    }
    @media (orientation: landscape) and (max-height: 500px) {
      .bottom-sheet { min-height: 70vh; max-height: 90vh; }
      .truck-grid { grid-template-columns: repeat(4, 1fr); }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Top Controls -->
  <div class="top-bar">
    <div class="gps-status">
      <div class="gps-dot" id="gpsDot"></div>
      <span id="gpsText">GPS белсенді</span>
    </div>
    <div class="lang-switch">
      <button class="lang-btn active" onclick="setLang('kz', this)">KZ</button>
      <button class="lang-btn" onclick="setLang('ru', this)">RU</button>
    </div>
  </div>

  <!-- CENTER PIN -->
  <div class="center-pin" id="centerPin">
    <div class="pin-icon"></div>
  </div>

  <!-- Success Screen -->
  <div class="success-screen" id="successScreen">
    <div class="success-icon">🎉</div>
    <div class="success-title">Тапсырыс жіберілді!</div>
    <div class="success-message">
      Қол жетімді жүргізушілерді іздеп жатырмыз...<br />Бұл бірнеше секундқа созылады
    </div>
    <button class="success-btn" onclick="goToDriverList()">Жүргізушілерді көру</button>
  </div>

  <!-- Bottom Sheet -->
  <div class="bottom-sheet">
    <div class="sheet-handle"></div>
    <div class="step-indicator">
      <div class="step-dot active" id="step1"></div>
      <div class="step-dot" id="step2"></div>
      <div class="step-dot" id="step3"></div>
    </div>

    <div class="sheet-content">
      <!-- Step 1 -->
      <div class="form-step active" id="stepAddresses">
        <div class="address-section">
          <div class="address-card" onclick="openPicker('pickup')">
            <div class="marker">A</div>
            <div class="address-text">
              <div class="address-label" data-i18n="from">Қайдан</div>
              <div class="address-value" id="pickupAddr" data-i18n="locating">Орынды анықтау...</div>
            </div>
          </div>

          <div class="address-card" onclick="openPicker('dropoff')">
            <div class="marker dropoff">B</div>
            <div class="address-text">
              <div class="address-label" data-i18n="to">Қайда</div>
              <div class="address-value" id="dropoffAddr" data-i18n="selectDest">Баратын жерді таңдаңыз</div>
            </div>
          </div>

          <div class="route-info" id="routeInfo"></div>
        </div>

        <div class="button-grid single">
          <button class="btn btn-primary" id="nextStep1" onclick="goToStep(2)" disabled>Келесі</button>
        </div>
      </div>

      <!-- Step 2 -->
      <div class="form-step" id="stepDetails">
        <div class="form-title">Жеткізу мәліметтері</div>

        <div class="form-content">
          <div class="form-grid">
            <div class="form-field">
              <div class="field-label">💰 Баға (теңге)</div>
              <input type="number" class="field-input" id="price" placeholder="5000" min="2000" oninput="validateCurrentStep()"/>
            </div>
          </div>

          <div class="truck-section">
            <div class="truck-label">🚚 Көлік түрі</div>
            <div class="truck-grid">
              <div class="truck-option" data-truck="intercity" onclick="selectTruck('intercity', this)">
              <div class="truck-icon">🚕</div>
              <div class="truck-name" id="truckIntercityName">Қала аралық такси</div>
              <div class="truck-desc" id="truckIntercityDesc">қаладан қалаға</div>
            </div>

              <div class="truck-option" data-truck="small" onclick="selectTruck('small', this)">
                <div class="truck-icon">🚐</div>
                <div class="truck-name">Кіші</div>
                <div class="truck-desc">1.5т дейін</div>
              </div>
              <div class="truck-option" data-truck="medium" onclick="selectTruck('medium', this)">
                <div class="truck-icon">🚚</div>
                <div class="truck-name">Орташа</div>
                <div class="truck-desc">5т дейін</div>
              </div>
              <div class="truck-option" data-truck="large" onclick="selectTruck('large', this)">
                <div class="truck-icon">🚛</div>
                <div class="truck-name">Үлкен</div>
                <div class="truck-desc">20т дейін</div>
              </div>
              <div class="truck-option" data-truck="any" onclick="selectTruck('any', this)">
                <div class="truck-icon">🚙</div>
                <div class="truck-name">Кез келген</div>
                <div class="truck-desc">жарайды</div>
              </div>
            </div>
          </div>

          <div class="form-grid two-col">
            <div class="form-field">
              <div class="field-label">📅 Күні</div>
              <input type="date" class="field-input" id="date" oninput="validateCurrentStep()"/>
            </div>
            <div class="form-field">
              <div class="field-label">⏰ Уақыты</div>
              <input type="time" class="field-input" id="time" oninput="validateCurrentStep()"/>
            </div>
          </div>
        </div>

        <div class="button-grid double">
          <button class="btn btn-secondary" onclick="goToStep(1)">Артқа</button>
          <button class="btn btn-primary" id="nextStep2" onclick="goToStep(3)" disabled>Келесі</button>
        </div>
      </div>

      <!-- Step 3 -->
      <div class="form-step" id="stepContact">
        <div class="form-title">Байланыс ақпараты</div>

        <div class="form-content">
          <div class="form-grid">
            <div class="form-field">
              <div class="field-label">📱 Телефон</div>
              <input type="tel" class="field-input" id="phone" placeholder="+7 (___) ___-__-__" oninput="formatPhone(this); validateCurrentStep()"/>
            </div>

            <div class="form-field">
              <div class="field-label">💬 Түсініктеме (міндетті емес)</div>
              <textarea class="field-input" id="comment" placeholder="Қосымша ақпарат..."></textarea>
            </div>
          </div>
        </div>

        <div class="button-grid double">
          <button class="btn btn-secondary" onclick="goToStep(2)">Артқа</button>
          <button class="btn btn-primary" id="submitBtn" onclick="submitOrder()" disabled>
            <span id="submitText">Жіберу</span>
            <div class="loading" id="submitLoading" style="display: none;"></div>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Picker Modal -->
  <div class="picker-modal" id="pickerModal">
    <div id="pickerMap"></div>
    <div class="picker-header">
      <button class="back-btn" onclick="closePicker()">←</button>
      <input type="text" class="search-box" id="searchBox" placeholder="Мекенжай іздеу..." oninput="searchAddress(this.value)" onblur="hideSuggestionsDelayed()"/>
    </div>
    <div class="address-bar" id="pickerAddress">Картаны жүктеу...</div>
    <div class="picker-center-pin">
      <div class="pin-icon"></div>
    </div>
    <div class="suggestions" id="suggestions"></div>
    <button class="btn btn-primary confirm-btn" onclick="confirmPicker()">
      <span data-i18n="choose">Осы нүктені таңдау</span>
    </button>
  </div>

  <script>
    // ===== CONFIG =====
    const Y_KEY = '8a3e4da0-9ef2-4176-9203-e7014c1dba6f';
    const YA_LANG = () => (state.lang === 'kz' ? 'kk_KZ' : 'ru_RU');

    // ===== STATE =====
    let state = {
      lang: 'kz',
      userLoc: null,
      pickup: null,
      dropoff: null,
      pickingFor: null,
      route: null,
      currentStep: 1,
      selectedTruck: null,
      orderData: null,
      userHasPanned: false // Track if user manually panned map
    };

    const i18n = {
      kz: {
        from:'Қайдан', to:'Қайда', locating:'Орынды анықтау...', selectDest:'Баратын жерді таңдаңыз',
        submit:'Тапсырысты жіберу', gpsActive:'GPS белсенді', searching:'GPS іздеу...', choose:'Осы нүктені таңдау',
        intercityName:'Қала аралық такси', intercityDesc:'қаладан қалаға', distanceLabel:'Қашықтық'
      },
      ru: {
        from:'Откуда', to:'Куда', locating:'Определение местоположения...', selectDest:'Выберите адрес назначения',
        submit:'Отправить заказ', gpsActive:'GPS активен', searching:'Поиск GPS...', choose:'Выбрать эту точку',
        intercityName:'Межгород такси', intercityDesc:'между городами', distanceLabel:'Дистанция'
      }
    };


    // ===== Yandex v3 globals =====
    let map, pickerMap, userMarker, pickupMarker, dropoffMarker, routeLine;
    let pickerCenter = null;
    let geolocationWatchId = null;
    let pickerMapLoaded = false;
    let mapUpdateInterval = null;
    let locationPermissionGranted = false;
    let currentUserLocation = null;
    let suggestionsTimeout = null;

    // FIXED: Create HTML marker with proper positioning
    function createDivMarker(html, className = '', size = [24, 24]) {
      const el = document.createElement('div');
      el.className = className;
      el.style.width = size[0] + 'px';
      el.style.height = size[1] + 'px';
      if (html) el.innerHTML = html;
      return el;
    }

    // FIXED: Init main map with proper location handling
    async function initMap() {
      console.log('🗺️ Initializing map...');
      await ymaps3.ready;
      
      // Start location request immediately
      requestLocationPermission();
    }

    // FIXED: Proper location permission request
    function requestLocationPermission() {
      updateLocationStatus('searching', state.lang === 'kz' ? i18n.kz.searching : i18n.ru.searching);
      console.log('📍 Requesting location permission...');
      
      if (navigator.geolocation) {
        // Get current position with high accuracy
        navigator.geolocation.getCurrentPosition(
          (position) => {
            console.log('✅ Location permission granted:', position);
            locationPermissionGranted = true;
            
            // FIXED: Proper coordinate format [lat, lng]
            currentUserLocation = [position.coords.latitude, position.coords.longitude];
            state.userLoc = {
              lat: position.coords.latitude, 
              lng: position.coords.longitude, 
              accuracy: position.coords.accuracy
            };
            
            updateLocationStatus('active', `${state.lang === 'kz' ? i18n.kz.gpsActive : i18n.ru.gpsActive} ±${Math.round(position.coords.accuracy)}m`);
            
            // Initialize map with user location
            initMapWithPosition(currentUserLocation);
            
            // FIXED: Set pickup location to user location by default
            setUserLocationAsPickup();
            
            // Start real-time tracking
            startRealtimeLocationTracking();
          },
          (error) => {
            console.error('❌ Location permission denied:', error);
            updateLocationStatus('error', 'GPS қатесі');
            // Initialize with default location (Almaty)
            initMapWithPosition([43.238949, 76.889709]);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          }
        );
      } else {
        updateLocationStatus('error', 'GPS қол жетімді емес');
        initMapWithPosition([43.238949, 76.889709]);
      }
    }

    // FIXED: Set user location as default pickup point
    async function setUserLocationAsPickup() {
      if (!currentUserLocation) return;
      
      console.log('📍 Setting user location as pickup:', currentUserLocation);
      
      try {
        const addr = await reverseGeocode(currentUserLocation[0], currentUserLocation[1]);
        
        state.pickup = { 
          lat: currentUserLocation[0], 
          lng: currentUserLocation[1], 
          address: addr 
        };
        
        // Update UI
        document.getElementById('pickupAddr').textContent = addr;
        document.querySelectorAll('.address-card')[0].classList.add('filled');
        
        // Add pickup marker
        await addMarker('pickup', currentUserLocation[0], currentUserLocation[1]);
        
        validateCurrentStep();
        console.log('✅ User location set as pickup successfully');
        
      } catch (error) {
        console.error('❌ Error setting user location as pickup:', error);
      }
    }

    // FIXED: Real-time location tracking with better accuracy handling and 1s updates
    function startRealtimeLocationTracking() {
      if (!navigator.geolocation || !locationPermissionGranted) return;
      
      console.log('🔄 Starting real-time location tracking...');

      // Watch position for continuous updates
      geolocationWatchId = navigator.geolocation.watchPosition(
        (position) => {
          const newCoords = [position.coords.latitude, position.coords.longitude];
          const accuracy = position.coords.accuracy;
          
          console.log('📍 GPS update:', newCoords, 'accuracy:', accuracy);
          
          // FIXED: Remove strict accuracy gating - accept all updates
          currentUserLocation = newCoords;
          state.userLoc = {lat: newCoords[0], lng: newCoords[1], accuracy};
          
          updateUserMarker(newCoords[0], newCoords[1]);
          updateLocationStatus('active', `GPS белсенді ±${Math.round(accuracy)}m`);
          
          // Update pickup if it matches user location closely
          if (state.pickup && isCloseToUserLocation(state.pickup)) {
            updatePickupToUserLocation();
          }
        },
        (error) => {
          console.error('Real-time location error:', error);
          updateLocationStatus('error', 'GPS қатесі');
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 1000
        }
      );

      // FIXED: High-accuracy updates every 1 second (not 3s)
      mapUpdateInterval = setInterval(() => {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            const newCoords = [position.coords.latitude, position.coords.longitude];
            const accuracy = position.coords.accuracy;
            
            // FIXED: Accept all accuracy readings, not just <= 50m
            currentUserLocation = newCoords;
            state.userLoc = {lat: newCoords[0], lng: newCoords[1], accuracy};
            
            updateUserMarker(newCoords[0], newCoords[1]);
            updateLocationStatus('active', `GPS белсенді ±${Math.round(accuracy)}m`);
          },
          (error) => {
            console.error('Interval location error:', error);
          },
          {
            enableHighAccuracy: true,
            timeout: 2000,
            maximumAge: 0 // FIXED: Always get fresh location
          }
        );
      }, 1000); // FIXED: 1 second interval as requested
    }

    // Check if pickup point is close to user location
    function isCloseToUserLocation(pickup) {
      if (!currentUserLocation || !pickup) return false;
      const distance = calculateDistance(
        currentUserLocation[0], currentUserLocation[1],
        pickup.lat, pickup.lng
      );
      return distance < 0.05; // 50 meters
    }

    // Update pickup to current user location
    async function updatePickupToUserLocation() {
      if (!currentUserLocation) return;
      
      try {
        const addr = await reverseGeocode(currentUserLocation[0], currentUserLocation[1]);
        state.pickup = { 
          lat: currentUserLocation[0], 
          lng: currentUserLocation[1], 
          address: addr 
        };
        
        document.getElementById('pickupAddr').textContent = addr;
        
        // Update pickup marker
        if (pickupMarker && map) {
          pickupMarker.update({coordinates: [currentUserLocation[1], currentUserLocation[0]]});
        }
        
      } catch (error) {
        console.error('Error updating pickup to user location:', error);
      }
    }

    function updateLocationStatus(status, message) {
      const gpsText = document.getElementById('gpsText');
      const gpsDot = document.getElementById('gpsDot');
      
      if (gpsText) gpsText.textContent = message;
      if (gpsDot) {
        gpsDot.classList.remove('error');
        if (status === 'error') {
          gpsDot.classList.add('error');
        }
      }
    }

    // FIXED: Initialize map with basic layers only (no controls to avoid import issues)
    async function initMapWithPosition(center) {
      console.log('🗺️ Initializing map with position:', center);
      
      await ymaps3.ready;
      const { 
        YMap, 
        YMapDefaultSchemeLayer, 
        YMapDefaultFeaturesLayer, 
        YMapListener
      } = ymaps3;

      try {
        map = new YMap(document.getElementById('map'), {
          location: {
            center: [center[1], center[0]], // Yandex format: [lng, lat]
            zoom: 15
          }
        });

        // Add layers
        map.addChild(new YMapDefaultSchemeLayer({}));
        map.addChild(new YMapDefaultFeaturesLayer({}));

        // FIXED: Skip zoom controls to avoid import issues
        // TODO: Import controls package separately if needed

        // Add listener for manual pan detection
        const mapListener = new YMapListener({
          layer: 'any',
          onUpdate: () => {
            state.userHasPanned = true; // Stop auto-following after manual pan
          }
        });
        map.addChild(mapListener);

        console.log('✅ Map initialized successfully');

        // Add user location marker
        await addUserLocationMarker(center);

      } catch (error) {
        console.error('❌ Error initializing map:', error);
      }
    }

    // FIXED: Add user location marker with proper styling and animation
    async function addUserLocationMarker(coords) {
      if (!map) return;
      
      console.log('👤 Adding user location marker at:', coords);
      
      await ymaps3.ready;
      const { YMapMarker } = ymaps3;

      try {
        const el = createDivMarker('', 'user-marker', [14, 14]);

        userMarker = new YMapMarker({
          coordinates: [coords[1], coords[0]], // Yandex format: [lng, lat]
          draggable: false
        }, el);

        map.addChild(userMarker);
        console.log('✅ User location marker added');
        
      } catch (error) {
        console.error('❌ Error adding user marker:', error);
      }
    }

    // FIXED: Update user marker position with follow-me mode
    async function updateUserMarker(lat, lng) {
      try {
        // FIXED: Ensure marker exists before updating
        if (!userMarker && map) {
          console.log('Creating user marker as it doesn\'t exist');
          await addUserLocationMarker([lat, lng]);
          return;
        }
        
        if (!userMarker || !map) return;
        
        userMarker.update({
          coordinates: [lng, lat] // Yandex format: [lng, lat]
        });
        
        // FIXED: Implement proper follow-me mode instead of random centering
        if (state.currentStep === 1 && !state.userHasPanned) {
          map.update({ 
            location: { 
              center: [lng, lat], 
              zoom: map.location?.zoom || 15 
            },
            duration: 1000
          });
        }
        
      } catch (error) {
        console.error('❌ Error updating user marker:', error);
        // Try to recreate marker
        await addUserLocationMarker([lat, lng]);
      }
    }

    // FIXED: Build picker map without problematic controls
    async function buildPickerMap(center) {
  console.log('🗺️ Building picker map with center:', center);

  await ymaps3.ready;
  pickerMapLoaded = false;

  const { YMap, YMapDefaultSchemeLayer, YMapDefaultFeaturesLayer, YMapListener } = ymaps3;

  const el = document.getElementById('pickerMap');
  if (!el) {
    console.error('❌ Picker map element not found');
    return;
  }

  // Clear previous map
  if (pickerMap) {
    try { pickerMap.destroy(); } catch (e) { console.log('Cleaning up old picker map:', e.message); }
  }
  pickerMap = null;
  el.innerHTML = '';

  await new Promise(resolve => requestAnimationFrame(resolve));

  try {
    pickerMap = new YMap(el, {
      location: {
        center, // [lng, lat]
        zoom: 16
      }
    });

    pickerMap.addChild(new YMapDefaultSchemeLayer({}));
    pickerMap.addChild(new YMapDefaultFeaturesLayer({}));

    pickerMapLoaded = true;
    pickerCenter = center;            // <— keep our own center snapshot
    console.log('✅ Picker map created successfully');

    // Initial address update
    setTimeout(updatePickerAddress, 300);

    // Keep pickerCenter updated on any camera move
    let moveTimeout;
    const pickerListener = new YMapListener({
      onUpdate: (state) => {
        if (Array.isArray(state?.location?.center)) {
          pickerCenter = state.location.center; // [lng, lat]
          clearTimeout(moveTimeout);
          moveTimeout = setTimeout(updatePickerAddress, 250);
        }
      }
    });
    pickerMap.addChild(pickerListener);

  } catch (error) {
    console.error('❌ Error creating picker map:', error);
    document.getElementById('pickerAddress').textContent = 'Картаны жүктеу мүмкін болмады';
  }
}


    // FIXED: Update picker address
    async function updatePickerAddress() {
    if (!pickerMap || !pickerMapLoaded) return;
    if (!Array.isArray(pickerCenter) || pickerCenter.length !== 2) return;

    try {
      const [lng, lat] = pickerCenter; // [lng, lat]
      const addr = await reverseGeocode(lat, lng);
      document.getElementById('pickerAddress').textContent = addr;
    } catch (error) {
      console.error('❌ Address update error:', error);
      document.getElementById('pickerAddress').textContent = 'Мекенжайды анықтау мүмкін болмады';
    }
  }


    // ===== FIXED: Markers with proper coordinate handling =====
    async function addMarker(type, lat, lng) {
      if (!map) return;
      
      console.log(`📍 Adding ${type} marker at:`, lat, lng);
      
      await ymaps3.ready;
      const { YMapMarker } = ymaps3;

      try {
        const el = createDivMarker(type === 'pickup' ? 'A' : 'B', `custom-marker ${type}`);
        const marker = new YMapMarker({
          coordinates: [lng, lat], // Yandex format: [lng, lat]
          draggable: true
        }, el);

        if (type === 'pickup') {
          if (pickupMarker && map) {
            try { map.removeChild(pickupMarker); } catch (e) {}
          }
          pickupMarker = marker;
        } else {
          if (dropoffMarker && map) {
            try { map.removeChild(dropoffMarker); } catch (e) {}
          }
          dropoffMarker = marker;
        }
        
        map.addChild(marker);
        console.log(`✅ ${type} marker added successfully`);
        
      } catch (error) {
        console.error(`❌ Error adding ${type} marker:`, error);
      }
    }

    // ===== FIXED: Geocoding =====
    async function reverseGeocode(lat, lng) {
      try {
        const res = await fetch(
          `https://geocode-maps.yandex.ru/1.x/?apikey=${Y_KEY}&geocode=${lng},${lat}&format=json&lang=${YA_LANG()}&results=1`
        );
        
        if (!res.ok) throw new Error('Geocoding request failed');
        
        const data = await res.json();
        const coll = data.response?.GeoObjectCollection;
        const feature = coll?.featureMember?.[0]?.GeoObject;
        const text =
          feature?.metaDataProperty?.GeocoderMetaData?.Address?.formatted ||
          feature?.metaDataProperty?.GeocoderMetaData?.text;
          
        return text || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
      } catch (error) {
        console.error('❌ Geocoding error:', error);
        return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
      }
    }

    async function searchAddress(query) {
      if (query.length < 3) {
        document.getElementById('suggestions').classList.remove('active');
        return;
      }
      
      try {
        const res = await fetch(
          `https://geocode-maps.yandex.ru/1.x/?apikey=${Y_KEY}&geocode=${encodeURIComponent(
            query
          )}&format=json&lang=${YA_LANG()}&results=10&ll=76.889709,43.238949&spn=5,5`
        );
        
        const data = await res.json();
        const items = data.response?.GeoObjectCollection?.featureMember || [];
        
        const html = items
          .map(({ GeoObject }) => {
            const [lng, lat] = GeoObject.Point.pos.split(' ').map(Number);
            const md = GeoObject.metaDataProperty.GeocoderMetaData;
            const text = md?.Address?.formatted || md?.text || `${lat}, ${lng}`;
            return `<div class="suggestion-item" onclick="selectSuggestion(${lat}, ${lng})">${text}</div>`;
          })
          .join('');
          
        const sug = document.getElementById('suggestions');
        sug.innerHTML = html;
        sug.classList.add('active');
        
      } catch (error) {
        console.error('❌ Search error:', error);
      }
    }

    function selectSuggestion(lat, lng) {
  if (pickerMap && pickerMapLoaded) {
    const center = [lng, lat];
    pickerCenter = center; // update immediately
    pickerMap.update({ location: { center, zoom: 17 } });
    updatePickerAddress();
  }
  document.getElementById('suggestions').classList.remove('active');
  document.getElementById('searchBox').value = '';
}


    // FIXED: Hide suggestions with delay to allow clicks
    function hideSuggestionsDelayed() {
      clearTimeout(suggestionsTimeout);
      suggestionsTimeout = setTimeout(() => {
        document.getElementById('suggestions').classList.remove('active');
      }, 200);
    }

    // ===== FIXED: Routing with proper YMapFeature access =====
    async function drawRoute() {
      if (!state.pickup || !state.dropoff) return;
      
      // Remove old route
      if (routeLine && map) {
        try { map.removeChild(routeLine); } catch (e) {}
        routeLine = null;
      }

      try {
        console.log('🛣️ Drawing route from', state.pickup, 'to', state.dropoff);
        
        const url = `https://api.routing.yandex.net/v2/route?apikey=${Y_KEY}&waypoints=${state.pickup.lng},${state.pickup.lat}|${state.dropoff.lng},${state.dropoff.lat}&mode=driving&format=json`;
        const res = await fetch(url);
        const data = await res.json();

        const geometry = data?.route?.geometry;
        const legs = data?.route?.legs;
        
        if (!geometry?.coordinates || !legs?.length) {
          console.log('No route found, drawing straight line');
          await drawStraightLine();
          return;
        }

        await ymaps3.ready;
        const { YMapFeature } = ymaps3;

        routeLine = new YMapFeature({
          geometry: { type: 'LineString', coordinates: geometry.coordinates },
          style: { stroke: [{ color: '#10b981', width: 4 }] }
        });
        
        map.addChild(routeLine);

        const distance = legs[0]?.distance?.value || 0;
        const duration = legs[0]?.duration?.value || 0;

        // Fit bounds
        const bounds = calculateRouteBounds([
          [state.pickup.lng, state.pickup.lat],
          [state.dropoff.lng, state.dropoff.lat]
        ]);
        
        map.update({
          location: { bounds: bounds },
          duration: 1000
        });

        const km = (distance / 1000).toFixed(1);
        const min = Math.round(duration / 60);
        state.route = { distance, duration };
        
        document.getElementById('routeInfo').innerHTML = `
          <div style="display:flex;align-items:center;justify-content:center;gap:12px;">
            <span>🛣️ ${km} км</span>
            <span>⏱️ ${min} мин</span>
          </div>`;
        document.getElementById('routeInfo').classList.add('active');
        
        console.log('✅ Route drawn successfully');
        
      } catch (error) {
        console.error('❌ Route error:', error);
        await drawStraightLine();
      }
    }

    // FIXED: Guard YMapFeature access
    async function drawStraightLine() {
      if (!state.pickup || !state.dropoff || !map) return;
      
      try {
        const coords = [
          [state.pickup.lng, state.pickup.lat],
          [state.dropoff.lng, state.dropoff.lat]
        ];
        
        await ymaps3.ready; // FIXED: Ensure readiness before access
        const { YMapFeature } = ymaps3;
        
        routeLine = new YMapFeature({
          geometry: { type: 'LineString', coordinates: coords },
          style: { stroke: [{ color: '#10b981', width: 4, opacity: 0.7 }] }
        });
        
        map.addChild(routeLine);
        
        // Calculate and display straight-line distance
        const distance = calculateDistance(
          state.pickup.lat, state.pickup.lng,
          state.dropoff.lat, state.dropoff.lng
        );
        
        document.getElementById('routeInfo').innerHTML = `
          <div style="display:flex;align-items:center;justify-content:center;gap:12px;">
            <span>📏 ${distance.toFixed(1)} км</span>
          </div>`;
        document.getElementById('routeInfo').classList.add('active');
        
      } catch (error) {
        console.error('❌ Error drawing straight line:', error);
      }
    }

    function calculateRouteBounds(coordinates) {
      let minLng = coordinates[0][0];
      let maxLng = coordinates[0][0];
      let minLat = coordinates[0][1];
      let maxLat = coordinates[0][1];
      
      coordinates.forEach(coord => {
        minLng = Math.min(minLng, coord[0]);
        maxLng = Math.max(maxLng, coord[0]);
        minLat = Math.min(minLat, coord[1]);
        maxLat = Math.max(maxLat, coord[1]);
      });
      
      const padding = 0.01;
      return [
        [minLng - padding, minLat - padding],
        [maxLng + padding, maxLat + padding]
      ];
    }

    // Calculate distance using Haversine formula
    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 6371; // Earth's radius in kilometers
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // ===== Steps & Validation =====
    function goToStep(step) {
      document.querySelectorAll('.form-step').forEach((s) => s.classList.remove('active'));
      document.querySelectorAll('.step-dot').forEach((d) => d.classList.remove('active'));

      document
        .getElementById(`step${step === 1 ? 'Addresses' : step === 2 ? 'Details' : 'Contact'}`)
        .classList.add('active');
      document.getElementById(`step${step}`).classList.add('active');

      state.currentStep = step;
      validateCurrentStep();
    }

    function validateCurrentStep() {
      let isValid = false;

      if (state.currentStep === 1) {
        isValid = state.pickup && state.dropoff;
        document.getElementById('nextStep1').disabled = !isValid;
      } else if (state.currentStep === 2) {
        const price = Number(document.getElementById('price').value);
        const date = document.getElementById('date').value;
        const time = document.getElementById('time').value;
        isValid = price >= 2000 && date && time && state.selectedTruck;
        document.getElementById('nextStep2').disabled = !isValid;
      } else if (state.currentStep === 3) {
        const phone = document.getElementById('phone').value;
        isValid = phone.length >= 18;
        document.getElementById('submitBtn').disabled = !isValid;
      }
    }

    // FIXED: selectTruck with explicit element parameter
    function selectTruck(type, element) {
      document.querySelectorAll('.truck-option').forEach((opt) => opt.classList.remove('selected'));
      element.classList.add('selected');
      state.selectedTruck = type;
      validateCurrentStep();
    }

    // ===== FIXED: Picker open/close/confirm =====
    async function openPicker(type) {
      console.log('🗺️ Opening picker for:', type);
      state.pickingFor = type;
      
      const modal = document.getElementById('pickerModal');
      modal.classList.add('active');

      // Choose center based on type
      let center;
      if (type === 'pickup' && state.pickup) {
        center = [state.pickup.lng, state.pickup.lat]; // Yandex format
      } else if (type === 'dropoff' && state.dropoff) {
        center = [state.dropoff.lng, state.dropoff.lat]; // Yandex format
      } else if (currentUserLocation) {
        center = [currentUserLocation[1], currentUserLocation[0]]; // Convert to Yandex format
      } else {
        center = [76.889709, 43.238949]; // Default Almaty
      }

      console.log('Using center for picker:', center);

      document.getElementById('pickerAddress').textContent = 'Картаны жүктеу...';

      await new Promise(resolve => setTimeout(resolve, 100));
      await buildPickerMap(center);
    }

    function closePicker() {
      const modal = document.getElementById('pickerModal');
      modal.classList.remove('active');
      
      document.getElementById('suggestions').classList.remove('active');
      document.getElementById('searchBox').value = '';
      
      if (pickerMap) {
        try { 
          pickerMap.destroy(); 
        } catch (e) { 
          console.log('Cleaning up picker map:', e.message); 
        }
      }
      pickerMap = null;
      pickerMapLoaded = false;
      
      state.pickingFor = null;
    }

    // FIXED: Confirm picker with fallback for when map isn't ready
    async function confirmPicker() {
  console.log('✅ Confirming picker selection...');

  if (!state.pickingFor) {
    console.log('❌ No selection type specified');
    return;
  }

  if (!Array.isArray(pickerCenter) || pickerCenter.length !== 2) {
    const msg = state.lang === 'kz'
      ? 'Карта әлі жүктелуде. Қайта байқап көріңіз.'
      : 'Карта еще загружается. Попробуйте снова.';
    if (window.Telegram?.WebApp) Telegram.WebApp.showAlert(msg); else alert(msg);
    return;
  }

  try {
    const [lng, lat] = pickerCenter; // [lng, lat]
    console.log('📍 Selected coordinates:', { lat, lng });

    const addr = await reverseGeocode(lat, lng);
    console.log('📍 Address:', addr);

    if (state.pickingFor === 'pickup') {
      state.pickup = { lat, lng, address: addr };
      document.getElementById('pickupAddr').textContent = addr;
      document.querySelectorAll('.address-card')[0].classList.add('filled');
      await addMarker('pickup', lat, lng);
    } else {
      state.dropoff = { lat, lng, address: addr };
      document.getElementById('dropoffAddr').textContent = addr;
      document.querySelectorAll('.address-card')[1].classList.add('filled');
      await addMarker('dropoff', lat, lng);
    }

    closePicker();

    if (state.pickup && state.dropoff) drawRoute();
    validateCurrentStep();

    console.log('✅ Picker confirmation successful');
  } catch (error) {
    console.error('❌ Confirm picker error:', error);
  }
}


    // ===== Phone format =====
    function formatPhone(input) {
      let val = input.value.replace(/\D/g, '');
      if (!val) return;
      if (val[0] !== '7') val = '7' + val;

      let fmt = '+7';
      if (val.length > 1) fmt += ` (${val.slice(1, 4)}`;
      if (val.length >= 4) fmt += ')';
      if (val.length > 4) fmt += ` ${val.slice(4, 7)}`;
      if (val.length > 7) fmt += `-${val.slice(7, 9)}`;
      if (val.length > 9) fmt += `-${val.slice(9, 11)}`;

      input.value = fmt;
    }

    // ===== Submit order =====
    async function submitOrder() {
      const submitBtn = document.getElementById('submitBtn');
      const submitText = document.getElementById('submitText');
      const submitLoading = document.getElementById('submitLoading');
      const tg = window.Telegram?.WebApp;

      submitBtn.disabled = true;
      submitText.style.display = 'none';
      submitLoading.style.display = 'block';

      try {
        const formData = new FormData();
        formData.append('from_address', state.pickup.address);
        formData.append('from_lat', state.pickup.lat);
        formData.append('from_lon', state.pickup.lng);
        formData.append('to_address', state.dropoff.address);
        formData.append('to_lat', state.dropoff.lat);
        formData.append('to_lon', state.dropoff.lng);
        formData.append('price', document.getElementById('price').value);
        formData.append('truck_type', state.selectedTruck);
        formData.append('date', document.getElementById('date').value);
        formData.append('time', document.getElementById('time').value);
        formData.append('contact', document.getElementById('phone').value);
        formData.append('comment', document.getElementById('comment').value);

        if (tg?.initDataUnsafe?.user) {
          formData.append('telegram_id', tg.initDataUnsafe.user.id);
          formData.append('telegram_username', tg.initDataUnsafe.user.username || '');
          formData.append('telegram_first_name', tg.initDataUnsafe.user.first_name || '');
          formData.append('telegram_last_name', tg.initDataUnsafe.user.last_name || '');
        }

        if (state.route) {
          formData.append('distance', state.route.distance);
          formData.append('duration', state.route.duration);
        }

        const res = await fetch('/api/delivery-request', { method: 'POST', body: formData });
        const json = await res.json().catch(() => ({ success: false }));

        if (json?.success) {
          state.orderData = {
            pickup: state.pickup,
            dropoff: state.dropoff,
            price: document.getElementById('price').value,
            truck_type: state.selectedTruck,
            contact: document.getElementById('phone').value,
            comment: document.getElementById('comment').value,
            request_id: json.data?.request_id
          };
          showSuccessScreen();
          stopRealtimeGeolocation();
        } else {
          throw new Error(json?.message || 'Request failed');
        }
      } catch (error) {
        const errorMsg = `Error: ${error.message}`;
        const tg = window.Telegram?.WebApp;
        if (tg) tg.showAlert(errorMsg);
        else alert(errorMsg);
      } finally {
        submitBtn.disabled = false;
        submitText.style.display = 'block';
        submitLoading.style.display = 'none';
        validateCurrentStep();
      }
    }

    function showSuccessScreen() {
      document.getElementById('successScreen').classList.add('active');
      setTimeout(() => {
        goToDriverList();
      }, 3000);
    }

    function goToDriverList() {
      const orderData = encodeURIComponent(JSON.stringify(state.orderData));
      window.location.href = `/driver-list?order=${orderData}`;
    }

    // CLEANUP FUNCTION
    function stopRealtimeGeolocation() {
      if (geolocationWatchId) {
        navigator.geolocation.clearWatch(geolocationWatchId);
        geolocationWatchId = null;
      }
      if (mapUpdateInterval) {
        clearInterval(mapUpdateInterval);
        mapUpdateInterval = null;
      }
    }

    // FIXED: Lang with explicit element parameter
    function setLang(lang, element) {
      state.lang = lang;
      document.querySelectorAll('.lang-btn').forEach((btn) => btn.classList.remove('active'));
      element.classList.add('active');

      document.querySelectorAll('[data-i18n]').forEach((el) => {
        const key = el.dataset.i18n;
        if (i18n[lang][key]) el.textContent = i18n[lang][key];
      });

      if (lang === 'kz') {
        document.getElementById('gpsText').textContent = 'GPS белсенді';
        document.querySelector('.success-title').textContent = 'Тапсырыс жіберілді!';
        document.querySelector('.success-message').textContent =
          'Қол жетімді жүргізушілерді іздеп жатырмыз...\nБұл бірнеше секундқа созылады';
        document.querySelector('.success-btn').textContent = 'Жүргізушілерді көру';
      } else {
        document.getElementById('gpsText').textContent = 'GPS активен';
        document.querySelector('.success-title').textContent = 'Заказ отправлен!';
        document.querySelector('.success-message').textContent =
          'Ищем доступных водителей...\nЭто займет несколько секунд';
        document.querySelector('.success-btn').textContent = 'Посмотреть водителей';
      }
    }

    // ===== Boot =====
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('🚀 DOM loaded, initializing app...');
      
      if (!window.ymaps3) {
        console.error('❌ Yandex Maps v3 failed to load');
        return;
      }
      
      await initMap();
      console.log('✅ Map initialization started');

      // Default date/time
      const now = new Date();
      document.getElementById('date').valueAsDate = now;
      document.getElementById('time').value = now.toTimeString().slice(0, 5);

      // Default language
      setLang('kz', document.querySelector('.lang-btn.active'));

      // Telegram WebApp setup
      if (window.Telegram?.WebApp) {
        const tg = Telegram.WebApp;
        tg.ready();
        tg.expand();
        tg.disableVerticalSwipes();
        console.log('✅ Telegram WebApp initialized');
      }
    });

    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
      stopRealtimeGeolocation();
    });

    // Reset user pan flag when going to step 1
    document.addEventListener('click', (e) => {
      if (e.target.textContent === 'Келесі' && state.currentStep === 2) {
        state.userHasPanned = false; // Reset for new address selection
      }
    });

    // Expose functions globally
    window.setLang = setLang;
    window.openPicker = openPicker;
    window.closePicker = closePicker;
    window.confirmPicker = confirmPicker;
    window.searchAddress = searchAddress;
    window.selectSuggestion = selectSuggestion;
    window.goToStep = goToStep;
    window.selectTruck = selectTruck;
    window.formatPhone = formatPhone;
    window.submitOrder = submitOrder;
    window.goToDriverList = goToDriverList;
    window.hideSuggestionsDelayed = hideSuggestionsDelayed;
  </script>
</body>
</html>