<!DOCTYPE html>
<html lang="kz">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="theme-color" content="#000000" />
  <title>Delivery - Full Screen</title>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script defer src="https://api-maps.yandex.ru/v3/?apikey=8a3e4da0-9ef2-4176-9203-e7014c1dba6f&lang=ru_RU"></script>

  <style>
    /* CSS Custom Properties for Dynamic Heights */
    :root {
      --tg-viewport-height: 100vh;
      --tg-viewport-stable-height: 100vh;
      --tg-safe-area-inset-top: 0px;
      --tg-safe-area-inset-bottom: 0px;
      --tg-safe-area-inset-left: 0px;
      --tg-safe-area-inset-right: 0px;
      --tg-content-safe-area-inset-top: 0px;
      --system-ui-height: 0px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html {
      height: 100%;
      height: 100vh;
      height: 100dvh;
      overflow: hidden;
      position: fixed;
      width: 100%;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      height: var(--tg-viewport-stable-height, 100vh);
      height: var(--tg-viewport-stable-height, 100dvh);
      overflow: hidden;
      background: #f8f9fa;
      position: fixed;
      width: 100%;
      top: 0;
      left: 0;
      /* Dynamic padding with safe areas */
      padding-top: calc(var(--tg-safe-area-inset-top, env(safe-area-inset-top, 0px)) + var(--tg-content-safe-area-inset-top, 0px) + 15px);
      padding-bottom: calc(var(--tg-safe-area-inset-bottom, env(safe-area-inset-bottom, 0px)) + 10px);
      padding-left: calc(var(--tg-safe-area-inset-left, env(safe-area-inset-left, 0px)) + 0px);
      padding-right: calc(var(--tg-safe-area-inset-right, env(safe-area-inset-right, 0px)) + 0px);
    }

    /* Full screen maps */
    #map, #pickerMap {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: var(--tg-viewport-stable-height, 100vh);
      height: var(--tg-viewport-stable-height, 100dvh);
      touch-action: none;
      -webkit-touch-action: none;
      -ms-touch-action: none;
      z-index: 1;
    }

    /* Top Controls - Fixed positioning with safe area */
    .top-bar {
      position: fixed;
      top: calc(var(--tg-safe-area-inset-top, env(safe-area-inset-top, 12px)) + var(--tg-content-safe-area-inset-top, 0px) + 8px);
      left: calc(var(--tg-safe-area-inset-left, env(safe-area-inset-left, 12px)) + 8px);
      right: calc(var(--tg-safe-area-inset-right, env(safe-area-inset-right, 12px)) + 8px);
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      pointer-events: none;
    }

    .gps-status, .lang-switch {
      pointer-events: auto;
    }

    .gps-status {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 10px 14px;
      border-radius: 18px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      font-size: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .gps-dot {
      width: 6px;
      height: 6px;
      background: #10b981;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    .gps-dot.error {
      background: #ef4444;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    .lang-switch {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 18px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      display: flex;
      padding: 2px;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .lang-btn {
      padding: 6px 12px;
      border: none;
      background: none;
      border-radius: 16px;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      color: #6b7280;
    }
    .lang-btn.active {
      background: #000;
      color: white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    /* Bottom sheet - Dynamic height with safe area */
    .bottom-sheet {
      position: fixed;
      bottom: calc(var(--tg-safe-area-inset-bottom, env(safe-area-inset-bottom, 0px)));
      left: calc(var(--tg-safe-area-inset-left, env(safe-area-inset-left, 0px)));
      right: calc(var(--tg-safe-area-inset-right, env(safe-area-inset-right, 0px)));
      background: white;
      border-radius: 24px 24px 0 0;
      box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.12);
      z-index: 1001;
      height: auto;
      min-height: calc(var(--tg-viewport-stable-height, 100vh) * 0.45);
      max-height: calc(var(--tg-viewport-stable-height, 100vh) * 0.85);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      display: flex;
      flex-direction: column;
    }

    .sheet-handle {
      width: 36px;
      height: 4px;
      background: #d1d5db;
      border-radius: 2px;
      margin: 8px auto 6px;
      flex-shrink: 0;
    }

    .sheet-content {
      flex: 1;
      padding: 0 16px calc(var(--tg-safe-area-inset-bottom, env(safe-area-inset-bottom, 16px)) + 16px);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .step-indicator {
      display: flex;
      justify-content: center;
      gap: 6px;
      margin-bottom: 16px;
      padding: 0;
      flex-shrink: 0;
    }

    .step-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #e5e7eb;
      transition: all 0.3s ease;
    }
    .step-dot.active {
      background: #000;
      transform: scale(1.3);
    }

    .address-section {
      flex-shrink: 0;
      margin-bottom: 16px;
    }

    .address-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 12px;
      background: #f8f9fa;
      border-radius: 16px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
      position: relative;
      overflow: hidden;
      min-height: 56px;
    }
    .address-card:active { transform: scale(0.98); }
    .address-card.filled {
      background: linear-gradient(135deg, #f0fdf4, #dcfce7);
      border-color: #10b981;
    }
    .address-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, #10b981, #059669);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }
    .address-card.filled::before { transform: scaleX(1); }

    .marker {
      width: 32px !important;
      height: 32px !important;
      border-radius: 50% !important;
      background: #000 !important;
      color: white !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      font-weight: 700 !important;
      font-size: 14px !important;
      flex-shrink: 0 !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
    }
    .marker.dropoff {
      background: linear-gradient(135deg, #ef4444, #dc2626) !important;
    }

    .address-text {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .address-label {
      font-size: 11px;
      color: #6b7280;
      margin: 0;
      font-weight: 600;
      letter-spacing: 0.3px;
      line-height: 1;
    }

    .address-value {
      font-size: 14px;
      font-weight: 600;
      line-height: 1.1;
      color: #111827;
      margin-top: 3px;
      margin-bottom: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Distance info */
    .distance-info {
      padding: 12px;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      border-radius: 14px;
      margin: 8px 0;
      text-align: center;
      font-size: 12px;
      font-weight: 600;
      display: none;
      box-shadow: 0 4px 16px rgba(16, 185, 129, 0.3);
      flex-shrink: 0;
    }
    .distance-info.active {
      display: block;
      animation: slideUp 0.4s ease;
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translateY(16px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .form-step {
      display: none;
      flex: 1;
      flex-direction: column;
      min-height: 0;
    }
    .form-step.active { display: flex; }

    .form-title {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 16px;
      color: #111827;
      flex-shrink: 0;
    }

    .form-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow-y: auto;
    }

    .form-grid {
      display: grid;
      gap: 10px;
      margin-bottom: 16px;
      flex-shrink: 0;
    }
    .form-grid.two-col { grid-template-columns: 1fr 1fr; }

    .form-field {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 12px;
      border: 2px solid transparent;
      transition: all 0.2s ease;
    }
    .form-field:focus-within {
      border-color: #10b981;
      background: white;
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.08);
    }

    .field-label {
      font-size: 10px;
      color: #6b7280;
      margin-bottom: 6px;
      font-weight: 600;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .field-input {
      width: 100%;
      border: none;
      background: none;
      font-size: 14px;
      font-weight: 500;
      outline: none;
      color: #111827;
    }
    .field-input::placeholder { color: #9ca3af; }

    textarea.field-input {
      min-height: 48px;
      resize: none;
      font-family: inherit;
      line-height: 1.3;
    }

    .truck-section {
      flex-shrink: 0;
      margin-bottom: 16px;
    }

    .truck-label {
      font-size: 10px;
      color: #6b7280;
      margin-bottom: 10px;
      font-weight: 600;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .truck-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      margin-bottom: 16px;
    }

    .truck-option {
      padding: 10px;
      background: #f8f9fa;
      border-radius: 12px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }
    .truck-option:active { transform: scale(0.96); }
    .truck-option.selected {
      border-color: #10b981;
      background: linear-gradient(135deg, #f0fdf4, #dcfce7);
      box-shadow: 0 6px 20px rgba(16,185,129,.25);
      transform: translateY(-1px);
    }

    .truck-icon {
      font-size: 16px;
      margin-bottom: 4px;
    }

    .truck-name {
      font-size: 11px;
      font-weight: 600;
      color: #111827;
      margin-bottom: 2px;
    }

    .truck-desc {
      font-size: 9px;
      color: #6b7280;
    }

    .btn {
      width: 100%;
      padding: 14px;
      border: none;
      border-radius: 14px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      position: relative;
      overflow: hidden;
    }

    .btn-primary {
      background: linear-gradient(135deg, #000, #1f2937);
      color: white;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }
    .btn-primary:active {
      transform: scale(0.96);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    .btn-primary:disabled {
      background: #d1d5db;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-secondary {
      background: #f3f4f6;
      color: #374151;
      border: 1px solid #e5e7eb;
    }
    .btn-secondary:active {
      background: #e5e7eb;
      transform: scale(0.96);
    }

    .button-grid {
      display: grid;
      gap: 10px;
      flex-shrink: 0;
      margin-top: 16px;
    }
    .button-grid.single { grid-template-columns: 1fr; }
    .button-grid.double { grid-template-columns: 1fr 1fr; }

    /* Success Screen */
    .success-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      padding: 20px;
      padding-top: calc(var(--tg-safe-area-inset-top, env(safe-area-inset-top, 20px)) + 40px);
      padding-bottom: calc(var(--tg-safe-area-inset-bottom, env(safe-area-inset-bottom, 20px)) + 20px);
    }
    .success-screen.active {
      display: flex;
      animation: successSlideIn 0.5s ease-out;
    }

    @keyframes successSlideIn {
      from { opacity: 0; transform: translateY(100%); }
      to { opacity: 1; transform: translateY(0); }
    }

    .success-icon {
      font-size: 72px;
      margin-bottom: 20px;
      animation: successPulse 2s infinite;
    }

    @keyframes successPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .success-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 12px;
    }

    .success-message {
      font-size: 16px;
      opacity: 0.9;
      margin-bottom: 24px;
      line-height: 1.4;
    }

    .success-btn {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      padding: 12px 24px;
      border-radius: 14px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .success-btn:active {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(0.96);
    }

    /* Picker Modal - Full screen */
    .picker-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: white;
      z-index: 2000;
      display: none;
    }
    .picker-modal.active {
      display: block;
      animation: slideInUp 0.3s ease;
    }

    @keyframes slideInUp {
      from { transform: translateY(100%); }
      to { transform: translateY(0); }
    }

    .picker-header {
      position: fixed;
      top: calc(var(--tg-safe-area-inset-top, env(safe-area-inset-top, 12px)) + var(--tg-content-safe-area-inset-top, 0px) + 8px);
      left: calc(var(--tg-safe-area-inset-left, env(safe-area-inset-left, 12px)) + 8px);
      right: calc(var(--tg-safe-area-inset-right, env(safe-area-inset-right, 12px)) + 8px);
      z-index: 2001;
      display: flex;
      gap: 10px;
    }

    .back-btn {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: none;
      border-radius: 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      flex-shrink: 0;
      transition: all 0.2s ease;
      font-size: 16px;
      font-weight: 600;
    }
    .back-btn:active { transform: scale(0.94); }

    .search-box {
      flex: 1;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: none;
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      font-size: 14px;
      outline: none;
      font-weight: 500;
    }

    /* Instructions for picker */
    .picker-instructions {
      position: fixed;
      top: calc(var(--tg-safe-area-inset-top, env(safe-area-inset-top, 68px)) + var(--tg-content-safe-area-inset-top, 0px) + 68px);
      left: calc(var(--tg-safe-area-inset-left, env(safe-area-inset-left, 12px)) + 8px);
      right: calc(var(--tg-safe-area-inset-right, env(safe-area-inset-right, 12px)) + 8px);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 12px;
      border-radius: 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      font-size: 12px;
      font-weight: 500;
      z-index: 2001;
      display: block;
      line-height: 1.4;
      text-align: center;
    }

    /* Confirm button - Full screen positioning */
    .confirm-btn {
      position: fixed;
      bottom: calc(var(--tg-safe-area-inset-bottom, env(safe-area-inset-bottom, 16px)) + 16px);
      left: calc(var(--tg-safe-area-inset-left, env(safe-area-inset-left, 16px)) + 8px);
      right: calc(var(--tg-safe-area-inset-right, env(safe-area-inset-right, 16px)) + 8px);
      z-index: 2020;
      pointer-events: auto;
      max-width: none;
    }

    .suggestions {
      position: fixed;
      top: calc(var(--tg-safe-area-inset-top, env(safe-area-inset-top, 120px)) + var(--tg-content-safe-area-inset-top, 0px) + 120px);
      left: calc(var(--tg-safe-area-inset-left, env(safe-area-inset-left, 12px)) + 8px);
      right: calc(var(--tg-safe-area-inset-right, env(safe-area-inset-right, 12px)) + 8px);
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 14px;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
      max-height: 35vh;
      overflow-y: auto;
      z-index: 2005;
      display: none;
    }
    .suggestions.active { display: block; }

    .suggestion-item {
      padding: 12px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.04);
      cursor: pointer;
      transition: background 0.2s ease;
      font-size: 13px;
    }
    .suggestion-item:active { background: rgba(0, 0, 0, 0.03); }
    .suggestion-item:last-child { border-bottom: none; }

    /* Map markers - Optimized for full screen */
    .user-marker {
      width: 14px !important;
      height: 14px !important;
      background: #3b82f6 !important;
      border: 2px solid white !important;
      border-radius: 50% !important;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4) !important;
      position: relative !important;
      animation: userPulse 2s infinite !important;
    }
    .user-marker::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 4px;
      height: 4px;
      background: white;
      border-radius: 50%;
    }

    @keyframes userPulse {
      0%, 100% { transform: scale(1); box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4); }
      50% { transform: scale(1.1); box-shadow: 0 2px 12px rgba(59, 130, 246, 0.6); }
    }

    .custom-marker {
      width: 20px !important;
      height: 20px !important;
      border-radius: 50% !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      font-weight: 700 !important;
      color: white !important;
      font-size: 11px !important;
      border: 1px solid white !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
      animation: markerBounce 0.5s ease-out !important;
      background: #000 !important;
    }
    .custom-marker.pickup {
      background: #000 !important;
    }
    .custom-marker.dropoff {
      background: #000 !important;
    }

    .placed-pin {
      width: 16px !important;
      height: 16px !important;
      background: #000 !important;
      border: 1px solid white !important;
      border-radius: 50% !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4) !important;
      animation: pinDrop 0.4s ease-out !important;
    }

    @keyframes markerBounce {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    @keyframes pinDrop {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.3); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Media queries for different screen sizes and orientations */
    @media (max-height: 700px) {
      .bottom-sheet { 
        min-height: calc(var(--tg-viewport-stable-height, 100vh) * 0.48); 
        max-height: calc(var(--tg-viewport-stable-height, 100vh) * 0.82); 
        /* Ensure no bottom gap */
        bottom: 0;
        padding-bottom: 0;
      }
      .truck-grid { grid-template-columns: repeat(4, 1fr); gap: 6px; }
      .truck-option { padding: 8px 4px; }
      .truck-name { font-size: 10px; }
      .truck-desc { font-size: 8px; }
      .sheet-content {
        padding-bottom: calc(var(--tg-safe-area-inset-bottom, env(safe-area-inset-bottom, 16px)) + 16px);
      }
    }

    @media (max-height: 600px) {
      .bottom-sheet { 
        min-height: calc(var(--tg-viewport-stable-height, 100vh) * 0.52); 
        max-height: calc(var(--tg-viewport-stable-height, 100vh) * 0.85); 
        /* Ensure no bottom gap */
        bottom: 0;
        padding-bottom: 0;
      }
      .form-grid.two-col { grid-template-columns: 1fr; }
      .sheet-content {
        padding-bottom: calc(var(--tg-safe-area-inset-bottom, env(safe-area-inset-bottom, 12px)) + 12px);
      }
    }

    @media (orientation: landscape) and (max-height: 500px) {
      .bottom-sheet { 
        min-height: calc(var(--tg-viewport-stable-height, 100vh) * 0.70); 
        max-height: calc(var(--tg-viewport-stable-height, 100vh) * 0.90); 
        /* Ensure no bottom gap */
        bottom: 0;
        padding-bottom: 0;
      }
      .truck-grid { grid-template-columns: repeat(4, 1fr); }
      .top-bar {
        top: calc(var(--tg-safe-area-inset-top, env(safe-area-inset-top, 8px)) + var(--tg-content-safe-area-inset-top, 0px) + 4px);
      }
      .sheet-content {
        padding-bottom: calc(var(--tg-safe-area-inset-bottom, env(safe-area-inset-bottom, 8px)) + 8px);
      }
    }

    /* Force bottom sheet to fill to bottom edge */
    @media (max-width: 480px) {
      .bottom-sheet {
        bottom: 0 !important;
        padding-bottom: 0 !important;
        border-radius: 20px 20px 0 0;
      }
      .sheet-content {
        padding-bottom: calc(var(--tg-safe-area-inset-bottom, env(safe-area-inset-bottom, 20px)) + 20px);
      }
    }

    /* iPhone X and newer safe area support */
    @supports (padding: max(0px)) {
      body {
        padding-top: max(calc(var(--tg-safe-area-inset-top, env(safe-area-inset-top, 0px)) + var(--tg-content-safe-area-inset-top, 0px) + 15px), 15px);
        padding-bottom: max(calc(var(--tg-safe-area-inset-bottom, env(safe-area-inset-bottom, 0px)) + 10px), 10px);
        padding-left: max(var(--tg-safe-area-inset-left, env(safe-area-inset-left, 0px)), 0px);
        padding-right: max(var(--tg-safe-area-inset-right, env(safe-area-inset-right, 0px)), 0px);
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Top Controls -->
  <div class="top-bar">
    <div class="gps-status">
      <div class="gps-dot" id="gpsDot"></div>
      <span id="gpsText">GPS белсенді</span>
    </div>
    <div class="lang-switch">
      <button class="lang-btn active" onclick="setLang('kz', this)">KZ</button>
      <button class="lang-btn" onclick="setLang('ru', this)">RU</button>
    </div>
  </div>

  <!-- Success Screen -->
  <div class="success-screen" id="successScreen">
    <div class="success-icon">🎉</div>
    <div class="success-title">Тапсырыс жіберілді!</div>
    <div class="success-message">
      Қол жетімді жүргізушілерді іздеп жатырмыз...<br />Бұл бірнеше секундқа созылады
    </div>
    <button class="success-btn" onclick="goToDriverList()">Жүргізушілерді көру</button>
  </div>

  <!-- Bottom Sheet -->
  <div class="bottom-sheet">
    <div class="sheet-handle"></div>
    <div class="step-indicator">
      <div class="step-dot active" id="step1"></div>
      <div class="step-dot" id="step2"></div>
      <div class="step-dot" id="step3"></div>
    </div>

    <div class="sheet-content">
      <!-- Step 1: Address Selection -->
      <div class="form-step active" id="stepAddresses">
        <div class="address-section">
          <div class="address-card" onclick="openPicker('pickup')">
            <div class="marker">A</div>
            <div class="address-text">
              <div class="address-label" data-i18n="from">Қайдан</div>
              <div class="address-value" id="pickupAddr" data-i18n="locating">Орынды анықтау...</div>
            </div>
          </div>

          <div class="address-card" onclick="openPicker('dropoff')">
            <div class="marker dropoff">B</div>
            <div class="address-text">
              <div class="address-label" data-i18n="to">Қайда</div>
              <div class="address-value" id="dropoffAddr" data-i18n="selectDest">Баратын жерді таңдаңыз</div>
            </div>
          </div>

          <div class="distance-info" id="distanceInfo"></div>
        </div>

        <div class="button-grid single">
          <button class="btn btn-primary" id="nextStep1" onclick="goToStep(2)" disabled>Келесі</button>
        </div>
      </div>

      <!-- Step 2: Order Details -->
      <div class="form-step" id="stepDetails">
        <div class="form-title">Жеткізу мәліметтері</div>

        <div class="form-content">
          <div class="form-grid">
            <div class="form-field">
              <div class="field-label">💰 Баға (теңге)</div>
              <input type="number" class="field-input" id="price" placeholder="5000" min="2000" oninput="validateCurrentStep()"/>
            </div>
          </div>

          <div class="truck-section">
            <div class="truck-label">🚚 Көлік түрі</div>
            <div class="truck-grid">
              <div class="truck-option" data-truck="intercity" onclick="selectTruck('intercity', this)">
                <div class="truck-icon">🚕</div>
                <div class="truck-name">Қала аралық такси</div>
                <div class="truck-desc">қаладан қалаға</div>
              </div>
              <div class="truck-option" data-truck="small" onclick="selectTruck('small', this)">
                <div class="truck-icon">🚐</div>
                <div class="truck-name">Кіші</div>
                <div class="truck-desc">1.5т дейін</div>
              </div>
              <div class="truck-option" data-truck="medium" onclick="selectTruck('medium', this)">
                <div class="truck-icon">🚚</div>
                <div class="truck-name">Орташа</div>
                <div class="truck-desc">5т дейін</div>
              </div>
              <div class="truck-option" data-truck="large" onclick="selectTruck('large', this)">
                <div class="truck-icon">🚛</div>
                <div class="truck-name">Үлкен</div>
                <div class="truck-desc">20т дейін</div>
              </div>
              <div class="truck-option" data-truck="any" onclick="selectTruck('any', this)">
                <div class="truck-icon">🚙</div>
                <div class="truck-name">Кез келген</div>
                <div class="truck-desc">жарайды</div>
              </div>
            </div>
          </div>

          <div class="form-grid two-col">
            <div class="form-field">
              <div class="field-label">📅 Күні</div>
              <input type="date" class="field-input" id="date" oninput="validateCurrentStep()"/>
            </div>
            <div class="form-field">
              <div class="field-label">⏰ Уақыты</div>
              <input type="time" class="field-input" id="time" oninput="validateCurrentStep()"/>
            </div>
          </div>
        </div>

        <div class="button-grid double">
          <button class="btn btn-secondary" onclick="goToStep(1)">Артқа</button>
          <button class="btn btn-primary" id="nextStep2" onclick="goToStep(3)" disabled>Келесі</button>
        </div>
      </div>

      <!-- Step 3: Contact Info -->
      <div class="form-step" id="stepContact">
        <div class="form-title">Байланыс ақпараты</div>

        <div class="form-content">
          <div class="form-grid">
            <div class="form-field">
              <div class="field-label">📱 Телефон</div>
              <input type="tel" class="field-input" id="phone" placeholder="+7 (___) ___-__-__" oninput="formatPhone(this); validateCurrentStep()"/>
            </div>

            <div class="form-field">
              <div class="field-label">💬 Түсініктеме (міндетті емес)</div>
              <textarea class="field-input" id="comment" placeholder="Қосымша ақпарат..."></textarea>
            </div>
          </div>
        </div>

        <div class="button-grid double">
          <button class="btn btn-secondary" onclick="goToStep(2)">Артқа</button>
          <button class="btn btn-primary" id="submitBtn" onclick="submitOrder()" disabled>
            <span id="submitText">Жіберу</span>
            <div class="loading" id="submitLoading" style="display: none;"></div>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Picker Modal -->
  <div class="picker-modal" id="pickerModal">
    <div id="pickerMap"></div>
    <div class="picker-header">
      <button class="back-btn" onclick="closePicker()">←</button>
      <input type="text" class="search-box" id="searchBox" placeholder="Мекенжай іздеу..." oninput="searchAddress(this.value)" onblur="hideSuggestionsDelayed()"/>
    </div>
    
    <!-- Instructions for manual pin placement -->
    <div class="picker-instructions" id="pickerInstructions">
      📍 Картада нүктені таңдау үшін басыңыз немесе жоғарыда іздеңіз
    </div>
    
    <div class="suggestions" id="suggestions"></div>
    <button class="btn btn-primary confirm-btn" onclick="confirmPicker()">
      <span data-i18n="choose">Осы нүктені таңдау</span>
    </button>
  </div>

  <script>
    // Configuration
    const Y_KEY = '8a3e4da0-9ef2-4176-9203-e7014c1dba6f';
    const YA_LANG = () => (state.lang === 'kz' ? 'kk_KZ' : 'ru_RU');

    // Application State
    let state = {
      lang: 'kz',
      userLoc: null,
      pickup: null,
      dropoff: null,
      pickingFor: null,
      currentStep: 1,
      selectedTruck: null,
      orderData: null,
      userHasPanned: false,
      manuallyPlacedPin: null
    };

    // Internationalization
    const i18n = {
      kz: {
        from:'Қайдан', to:'Қайда', locating:'Орынды анықтау...', selectDest:'Баратын жерді таңдаңыз',
        submit:'Тапсырысты жіберу', gpsActive:'GPS белсенді', searching:'GPS іздеу...', choose:'Осы нүктені таңдау',
        intercityName:'Қала аралық такси', intercityDesc:'қаладан қалаға', distanceLabel:'Қашықтық',
        clickToPlace: '📍 Картада нүктені таңдау үшін басыңыз немесе жоғарыда іздеңіз'
      },
      ru: {
        from:'Откуда', to:'Куда', locating:'Определение местоположения...', selectDest:'Выберите адрес назначения',
        submit:'Отправить заказ', gpsActive:'GPS активен', searching:'Поиск GPS...', choose:'Выбрать эту точку',
        intercityName:'Межгород такси', intercityDesc:'между городами', distanceLabel:'Дистанция',
        clickToPlace: '📍 Нажмите на карту чтобы выбрать точку или ищите выше'
      }
    };

    // Yandex Maps globals
    let map, pickerMap, userMarker, pickupMarker, dropoffMarker, placedPinMarker;
    let geolocationWatchId = null;
    let pickerMapLoaded = false;
    let mapUpdateInterval = null;
    let locationPermissionGranted = false;
    let currentUserLocation = null;
    let suggestionsTimeout = null;
    let lastUserPosition = null;

    // Dynamic viewport height management
    function updateViewportHeight() {
      let vh = window.innerHeight;
      
      if (window.Telegram && Telegram.WebApp) {
        vh = Telegram.WebApp.viewportHeight || vh;
        const stableHeight = Telegram.WebApp.viewportStableHeight || vh;
        const safeAreaTop = Telegram.WebApp.safeAreaInset?.top || 0;
        const safeAreaBottom = Telegram.WebApp.safeAreaInset?.bottom || 0;
        const safeAreaLeft = Telegram.WebApp.safeAreaInset?.left || 0;
        const safeAreaRight = Telegram.WebApp.safeAreaInset?.right || 0;
        const contentSafeAreaTop = Telegram.WebApp.contentSafeAreaInset?.top || 0;
        
        // Update CSS custom properties
        document.documentElement.style.setProperty('--tg-viewport-height', `${vh}px`);
        document.documentElement.style.setProperty('--tg-viewport-stable-height', `${stableHeight}px`);
        document.documentElement.style.setProperty('--tg-safe-area-inset-top', `${safeAreaTop}px`);
        document.documentElement.style.setProperty('--tg-safe-area-inset-bottom', `${safeAreaBottom}px`);
        document.documentElement.style.setProperty('--tg-safe-area-inset-left', `${safeAreaLeft}px`);
        document.documentElement.style.setProperty('--tg-safe-area-inset-right', `${safeAreaRight}px`);
        document.documentElement.style.setProperty('--tg-content-safe-area-inset-top', `${contentSafeAreaTop}px`);
        
        console.log('🔧 Viewport updated:', { vh, stableHeight, safeAreaTop, safeAreaBottom });
      } else {
        // Fallback for non-Telegram environments
        document.documentElement.style.setProperty('--tg-viewport-height', `${vh}px`);
        document.documentElement.style.setProperty('--tg-viewport-stable-height', `${vh}px`);
      }
    }

    // Utility: Create HTML marker element
    function createDivMarker(html, className = '', size = [20, 20]) {
      const el = document.createElement('div');
      el.className = className;
      el.style.width = size[0] + 'px';
      el.style.height = size[1] + 'px';
      if (html) el.innerHTML = html;
      return el;
    }

    // Main map initialization
    async function initMap() {
      console.log('🗺️ Initializing map...');
      await ymaps3.ready;
      requestLocationPermission();
    }

    // Location permission request
    function requestLocationPermission() {
      updateLocationStatus('searching', state.lang === 'kz' ? i18n.kz.searching : i18n.ru.searching);
      console.log('📍 Requesting location permission...');
      
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            console.log('✅ Location permission granted:', position);
            locationPermissionGranted = true;
            
            currentUserLocation = [position.coords.latitude, position.coords.longitude];
            state.userLoc = {
              lat: position.coords.latitude, 
              lng: position.coords.longitude, 
              accuracy: position.coords.accuracy
            };
            
            updateLocationStatus('active', `${state.lang === 'kz' ? i18n.kz.gpsActive : i18n.ru.gpsActive} ±${Math.round(position.coords.accuracy)}m`);
            
            initMapWithPosition(currentUserLocation);
            setUserLocationAsPickup();
            startRealtimeLocationTracking();
          },
          (error) => {
            console.error('❌ Location permission denied:', error);
            updateLocationStatus('error', 'GPS қатесі');
            initMapWithPosition([43.238949, 76.889709]);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          }
        );
      } else {
        updateLocationStatus('error', 'GPS қол жетімді емес');
        initMapWithPosition([43.238949, 76.889709]);
      }
    }

    // Set user location as default pickup
    async function setUserLocationAsPickup() {
      if (!currentUserLocation) return;
      
      console.log('📍 Setting user location as pickup:', currentUserLocation);
      
      try {
        const addr = await reverseGeocode(currentUserLocation[0], currentUserLocation[1]);
        
        state.pickup = { 
          lat: currentUserLocation[0], 
          lng: currentUserLocation[1], 
          address: addr 
        };
        
        document.getElementById('pickupAddr').textContent = addr;
        document.querySelectorAll('.address-card')[0].classList.add('filled');
        
        await addMarker('pickup', currentUserLocation[0], currentUserLocation[1]);
        validateCurrentStep();
        console.log('✅ User location set as pickup successfully');
        
      } catch (error) {
        console.error('❌ Error setting user location as pickup:', error);
      }
    }

    // OPTIMIZED: Real-time location tracking with fixed intervals
    function startRealtimeLocationTracking() {
      if (!navigator.geolocation || !locationPermissionGranted) return;
      
      console.log('🔄 Starting real-time location tracking...');

      // Watch position with high frequency
      geolocationWatchId = navigator.geolocation.watchPosition(
        (position) => {
          const newCoords = [position.coords.latitude, position.coords.longitude];
          const accuracy = position.coords.accuracy;
          
          console.log('📍 GPS update:', newCoords, 'accuracy:', accuracy);
          
          // RELAXED: Accept broader accuracy range
          if (accuracy <= 200) {
            currentUserLocation = newCoords;
            state.userLoc = {lat: newCoords[0], lng: newCoords[1], accuracy};
            
            updateUserMarker(newCoords[0], newCoords[1]);
            updateLocationStatus('active', `GPS белсенді ±${Math.round(accuracy)}m`);
            
            if (state.pickup && isCloseToUserLocation(state.pickup)) {
              updatePickupToUserLocation();
            }
          }
        },
        (error) => {
          console.error('Real-time location error:', error);
        },
        {
          enableHighAccuracy: true,
          timeout: 3000,
          maximumAge: 0
        }
      );

      // FIXED: Exactly 1 second interval polling
      mapUpdateInterval = setInterval(() => {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            const newCoords = [position.coords.latitude, position.coords.longitude];
            const accuracy = position.coords.accuracy;
            
            // RELAXED: Accept broader accuracy range
            if (accuracy <= 200) {
              currentUserLocation = newCoords;
              state.userLoc = {lat: newCoords[0], lng: newCoords[1], accuracy};
              
              updateUserMarker(newCoords[0], newCoords[1]);
              updateLocationStatus('active', `GPS белсенді ±${Math.round(accuracy)}m`);
            }
          },
          (error) => {
            console.warn('Interval location error:', error);
          },
          {
            enableHighAccuracy: true,
            timeout: 2000,
            maximumAge: 0 // FORCE fresh readings
          }
        );
      }, 1000); // EXACTLY 1 second
    }

    // Check if pickup is close to user location
    function isCloseToUserLocation(pickup) {
      if (!currentUserLocation || !pickup) return false;
      const distance = calculateDistance(
        currentUserLocation[0], currentUserLocation[1],
        pickup.lat, pickup.lng
      );
      return distance < 0.05;
    }

    // Update pickup to current user location
    async function updatePickupToUserLocation() {
      if (!currentUserLocation) return;
      
      try {
        const addr = await reverseGeocode(currentUserLocation[0], currentUserLocation[1]);
        state.pickup = { 
          lat: currentUserLocation[0], 
          lng: currentUserLocation[1], 
          address: addr 
        };
        
        document.getElementById('pickupAddr').textContent = addr;
        
        if (pickupMarker && map) {
          pickupMarker.update({coordinates: [currentUserLocation[1], currentUserLocation[0]]});
        }
        
      } catch (error) {
        console.error('Error updating pickup to user location:', error);
      }
    }

    function updateLocationStatus(status, message) {
      const gpsText = document.getElementById('gpsText');
      const gpsDot = document.getElementById('gpsDot');
      
      if (gpsText) gpsText.textContent = message;
      if (gpsDot) {
        gpsDot.classList.remove('error');
        if (status === 'error') {
          gpsDot.classList.add('error');
        }
      }
    }

    // Initialize map with position
    async function initMapWithPosition(center) {
      console.log('🗺️ Initializing map with position:', center);
      
      await ymaps3.ready;
      const { 
        YMap, 
        YMapDefaultSchemeLayer, 
        YMapDefaultFeaturesLayer, 
        YMapListener
      } = ymaps3;

      try {
        map = new YMap(document.getElementById('map'), {
          location: {
            center: [center[1], center[0]], // Yandex format: [lng, lat]
            zoom: 15
          }
        });

        map.addChild(new YMapDefaultSchemeLayer({}));
        map.addChild(new YMapDefaultFeaturesLayer({}));

        const mapListener = new YMapListener({
          layer: 'any',
          onUpdate: () => {
            state.userHasPanned = true;
          }
        });
        map.addChild(mapListener);

        console.log('✅ Map initialized successfully');
        await addUserLocationMarker(center);

      } catch (error) {
        console.error('❌ Error initializing map:', error);
      }
    }

    // Add user location marker
    async function addUserLocationMarker(coords) {
      if (!map) return;
      
      console.log('👤 Adding user location marker at:', coords);
      
      await ymaps3.ready;
      const { YMapMarker } = ymaps3;

      try {
        const el = createDivMarker('', 'user-marker', [14, 14]);

        userMarker = new YMapMarker({
          coordinates: [coords[1], coords[0]],
          draggable: false
        }, el);

        map.addChild(userMarker);
        console.log('✅ User location marker added');
        
      } catch (error) {
        console.error('❌ Error adding user marker:', error);
      }
    }

    // OPTIMIZED: Update user marker with micro-movement filtering
    async function updateUserMarker(lat, lng) {
      try {
        // Skip micro-movements
        if (lastUserPosition && 
            Math.abs(lastUserPosition[0] - lat) < 0.00001 && 
            Math.abs(lastUserPosition[1] - lng) < 0.00001) {
          return;
        }
        
        lastUserPosition = [lat, lng];
        
        if (!userMarker && map) {
          console.log('Creating user marker as it doesn\'t exist');
          await addUserLocationMarker([lat, lng]);
          return;
        }
        
        if (!userMarker || !map) return;
        
        userMarker.update({
          coordinates: [lng, lat]
        });
        
        // Auto-follow user ONLY if still on step 1 and hasn't manually panned
        if (state.currentStep === 1 && !state.userHasPanned) {
          map.update({ 
            location: { 
              center: [lng, lat], 
              zoom: map.location?.zoom || 15 
            },
            duration: 1000
          });
        }
        
      } catch (error) {
        console.error('❌ Error updating user marker:', error);
        await addUserLocationMarker([lat, lng]);
      }
    }

    // FIXED: Build picker map without problematic controls
    async function buildPickerMap(center) {
      console.log('🗺️ Building picker map with center:', center);

      await ymaps3.ready;
      pickerMapLoaded = false;

      const { YMap, YMapDefaultSchemeLayer, YMapDefaultFeaturesLayer, YMapListener } = ymaps3;

      const el = document.getElementById('pickerMap');
      if (!el) {
        console.error('❌ Picker map element not found');
        return;
      }

      if (pickerMap) {
        try { pickerMap.destroy(); } catch (e) { console.log('Cleaning up old picker map:', e.message); }
      }
      pickerMap = null;
      el.innerHTML = '';

      await new Promise(resolve => requestAnimationFrame(resolve));

      try {
        pickerMap = new YMap(el, {
          location: {
            center,
            zoom: 16
          }
        });

        pickerMap.addChild(new YMapDefaultSchemeLayer({}));
        pickerMap.addChild(new YMapDefaultFeaturesLayer({}));

        // CLICK LISTENER FOR MANUAL PIN PLACEMENT
        const clickListener = new YMapListener({
          layer: 'any',
          onClick: (object, event) => {
            if (event.coordinates) {
              placePinAtCoordinates(event.coordinates);
            }
          }
        });
        pickerMap.addChild(clickListener);

        // FIXED: Set loaded flag AFTER all setup is complete
        pickerMapLoaded = true;
        console.log('✅ Picker map created successfully with click listener');

        // Remove any existing placed pin marker
        if (placedPinMarker) {
          try { pickerMap.removeChild(placedPinMarker); } catch (e) {}
          placedPinMarker = null;
        }

        // Update instructions text
        updatePickerInstructions();

      } catch (error) {
        console.error('❌ Error creating picker map:', error);
        document.getElementById('pickerInstructions').textContent = 'Картаны жүктеу мүмкін болмады';
      }
    }

    // Place pin at coordinates (manual click)
    async function placePinAtCoordinates(coordinates) {
      if (!pickerMap || !pickerMapLoaded) return;
      
      console.log('📍 Placing pin at:', coordinates);
      
      await ymaps3.ready;
      const { YMapMarker } = ymaps3;

      try {
        // Remove existing placed pin
        if (placedPinMarker) {
          try { pickerMap.removeChild(placedPinMarker); } catch (e) {}
        }

        // Create new thin black pin
        const pinEl = createDivMarker('', 'placed-pin', [16, 16]);
        
        placedPinMarker = new YMapMarker({
          coordinates: coordinates,
          draggable: true
        }, pinEl);

        pickerMap.addChild(placedPinMarker);
        
        // Store coordinates for confirmation
        state.manuallyPlacedPin = {
          lat: coordinates[1],
          lng: coordinates[0]
        };
        
        // Update instructions to show pin is placed
        document.getElementById('pickerInstructions').textContent = 
          state.lang === 'kz' ? 
          '✅ Нүкте таңдалды! "Таңдау" батырмасын басыңыз' : 
          '✅ Точка выбрана! Нажмите "Выбрать"';

        console.log('✅ Pin placed successfully at:', coordinates);
        
      } catch (error) {
        console.error('❌ Error placing pin:', error);
      }
    }

    // Update picker instructions based on language
    function updatePickerInstructions() {
      const instructions = document.getElementById('pickerInstructions');
      if (instructions) {
        instructions.textContent = state.lang === 'kz' ? 
          i18n.kz.clickToPlace : 
          i18n.ru.clickToPlace;
      }
    }

    // Add marker to main map
    async function addMarker(type, lat, lng) {
      if (!map) return;
      
      console.log(`📍 Adding ${type} marker at:`, lat, lng);
      
      await ymaps3.ready;
      const { YMapMarker } = ymaps3;

      try {
        const el = createDivMarker(type === 'pickup' ? 'A' : 'B', `custom-marker ${type}`, [20, 20]);
        const marker = new YMapMarker({
          coordinates: [lng, lat],
          draggable: true
        }, el);

        if (type === 'pickup') {
          if (pickupMarker && map) {
            try { map.removeChild(pickupMarker); } catch (e) {}
          }
          pickupMarker = marker;
        } else {
          if (dropoffMarker && map) {
            try { map.removeChild(dropoffMarker); } catch (e) {}
          }
          dropoffMarker = marker;
        }
        
        map.addChild(marker);
        console.log(`✅ ${type} marker added successfully`);
        
        // OPTIMIZED: Center view on both points when both exist
        if (pickupMarker && dropoffMarker) {
          setTimeout(() => fitBothPointsOnMap(), 300);
        }
        
      } catch (error) {
        console.error(`❌ Error adding ${type} marker:`, error);
      }
    }

    // OPTIMIZED: Fit both A and B points comfortably on map
    function fitBothPointsOnMap() {
      if (!map || !state.pickup || !state.dropoff) return;
      
      try {
        const bounds = [
          [Math.min(state.pickup.lng, state.dropoff.lng), Math.min(state.pickup.lat, state.dropoff.lat)],
          [Math.max(state.pickup.lng, state.dropoff.lng), Math.max(state.pickup.lat, state.dropoff.lat)]
        ];
        
        // Add padding for comfortable view
        const padding = 0.01;
        bounds[0][0] -= padding; // left
        bounds[0][1] -= padding; // bottom
        bounds[1][0] += padding; // right
        bounds[1][1] += padding; // top
        
        map.update({
          location: { bounds: bounds },
          duration: 1500
        });
        
        // Show distance info
        showDistanceInfo();
        
        console.log('✅ Map fitted to show both points comfortably');
        
      } catch (error) {
        console.error('❌ Error fitting points on map:', error);
      }
    }

    // Show simple distance between two points
    function showDistanceInfo() {
      if (!state.pickup || !state.dropoff) return;
      
      const distance = calculateDistance(
        state.pickup.lat, state.pickup.lng,
        state.dropoff.lat, state.dropoff.lng
      );
      
      document.getElementById('distanceInfo').innerHTML = `
        <div style="display:flex;align-items:center;justify-content:center;gap:12px;">
          <span>📏 ${distance.toFixed(1)} км</span>
        </div>`;
      document.getElementById('distanceInfo').classList.add('active');
    }

    // OPTIMIZED: Debounced geocoding to reduce API calls
    let geocodeTimeout;
    function debouncedReverseGeocode(lat, lng) {
      return new Promise((resolve) => {
        clearTimeout(geocodeTimeout);
        geocodeTimeout = setTimeout(async () => {
          resolve(await reverseGeocode(lat, lng));
        }, 300);
      });
    }

    // Geocoding functions
    async function reverseGeocode(lat, lng) {
      try {
        const res = await fetch(
          `https://geocode-maps.yandex.ru/1.x/?apikey=${Y_KEY}&geocode=${lng},${lat}&format=json&lang=${YA_LANG()}&results=1`
        );
        
        if (!res.ok) throw new Error('Geocoding request failed');
        
        const data = await res.json();
        const coll = data.response?.GeoObjectCollection;
        const feature = coll?.featureMember?.[0]?.GeoObject;
        const text =
          feature?.metaDataProperty?.GeocoderMetaData?.Address?.formatted ||
          feature?.metaDataProperty?.GeocoderMetaData?.text;
          
        return text || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
      } catch (error) {
        console.error('❌ Geocoding error:', error);
        return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
      }
    }

    async function searchAddress(query) {
      if (query.length < 3) {
        document.getElementById('suggestions').classList.remove('active');
        return;
      }
      
      try {
        const res = await fetch(
          `https://geocode-maps.yandex.ru/1.x/?apikey=${Y_KEY}&geocode=${encodeURIComponent(
            query
          )}&format=json&lang=${YA_LANG()}&results=10&ll=76.889709,43.238949&spn=5,5`
        );
        
        const data = await res.json();
        const items = data.response?.GeoObjectCollection?.featureMember || [];
        
        const html = items
          .map(({ GeoObject }) => {
            const [lng, lat] = GeoObject.Point.pos.split(' ').map(Number);
            const md = GeoObject.metaDataProperty.GeocoderMetaData;
            const text = md?.Address?.formatted || md?.text || `${lat}, ${lng}`;
            return `<div class="suggestion-item" onclick="selectSuggestion(${lat}, ${lng})">${text}</div>`;
          })
          .join('');
          
        const sug = document.getElementById('suggestions');
        sug.innerHTML = html;
        sug.classList.add('active');
        
      } catch (error) {
        console.error('❌ Search error:', error);
      }
    }

    function selectSuggestion(lat, lng) {
      if (pickerMap && pickerMapLoaded) {
        const center = [lng, lat];
        pickerMap.update({ location: { center, zoom: 17 } });
        
        // Automatically place pin at searched location
        setTimeout(() => {
          placePinAtCoordinates([lng, lat]);
        }, 500);
      }
      document.getElementById('suggestions').classList.remove('active');
      document.getElementById('searchBox').value = '';
    }

    function hideSuggestionsDelayed() {
      clearTimeout(suggestionsTimeout);
      suggestionsTimeout = setTimeout(() => {
        document.getElementById('suggestions').classList.remove('active');
      }, 200);
    }

    // Calculate distance using Haversine formula
    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // Step navigation and validation
    function goToStep(step) {
      document.querySelectorAll('.form-step').forEach((s) => s.classList.remove('active'));
      document.querySelectorAll('.step-dot').forEach((d) => d.classList.remove('active'));

      document
        .getElementById(`step${step === 1 ? 'Addresses' : step === 2 ? 'Details' : 'Contact'}`)
        .classList.add('active');
      document.getElementById(`step${step}`).classList.add('active');

      state.currentStep = step;
      validateCurrentStep();
      
      // Reset user panning flag when going to step 1
      if (step === 1) {
        state.userHasPanned = false;
      }
    }

    function validateCurrentStep() {
      let isValid = false;

      if (state.currentStep === 1) {
        isValid = state.pickup && state.dropoff;
        document.getElementById('nextStep1').disabled = !isValid;
      } else if (state.currentStep === 2) {
        const price = Number(document.getElementById('price').value);
        const date = document.getElementById('date').value;
        const time = document.getElementById('time').value;
        isValid = price >= 2000 && date && time && state.selectedTruck;
        document.getElementById('nextStep2').disabled = !isValid;
      } else if (state.currentStep === 3) {
        const phone = document.getElementById('phone').value;
        isValid = phone.length >= 18;
        document.getElementById('submitBtn').disabled = !isValid;
      }
    }

    function selectTruck(type, element) {
      document.querySelectorAll('.truck-option').forEach((opt) => opt.classList.remove('selected'));
      element.classList.add('selected');
      state.selectedTruck = type;
      validateCurrentStep();
    }

    // Picker functions
    async function openPicker(type) {
      console.log('🗺️ Opening picker for:', type);
      state.pickingFor = type;
      
      const modal = document.getElementById('pickerModal');
      modal.classList.add('active');

      let center;
      if (type === 'pickup' && state.pickup) {
        center = [state.pickup.lng, state.pickup.lat];
      } else if (type === 'dropoff' && state.dropoff) {
        center = [state.dropoff.lng, state.dropoff.lat];
      } else if (currentUserLocation) {
        center = [currentUserLocation[1], currentUserLocation[0]];
      } else {
        center = [76.889709, 43.238949];
      }

      console.log('Using center for picker:', center);

      await new Promise(resolve => setTimeout(resolve, 100));
      await buildPickerMap(center);
    }

    function closePicker() {
      const modal = document.getElementById('pickerModal');
      modal.classList.remove('active');
      
      document.getElementById('suggestions').classList.remove('active');
      document.getElementById('searchBox').value = '';
      
      if (pickerMap) {
        try { 
          pickerMap.destroy(); 
        } catch (e) { 
          console.log('Cleaning up picker map:', e.message); 
        }
      }
      pickerMap = null;
      pickerMapLoaded = false;
      
      // Clean up placed pin
      if (placedPinMarker) {
        placedPinMarker = null;
      }
      state.manuallyPlacedPin = null;
      
      state.pickingFor = null;
    }

    // FIXED: Confirm picker selection using manually placed pin
    async function confirmPicker() {
      console.log('✅ Confirming picker selection...');

      if (!state.pickingFor) {
        console.log('❌ No selection type specified');
        return;
      }

      if (!state.manuallyPlacedPin) {
        const msg = state.lang === 'kz'
          ? 'Алдымен картада нүктені таңдаңыз'
          : 'Сначала выберите точку на карте';
        if (window.Telegram?.WebApp) Telegram.WebApp.showAlert(msg); else alert(msg);
        return;
      }

      try {
        const { lat, lng } = state.manuallyPlacedPin;
        console.log('📍 Selected coordinates:', { lat, lng });

        // Only call geocoding API once when confirming
        const addr = await reverseGeocode(lat, lng);
        console.log('📍 Address:', addr);

        if (state.pickingFor === 'pickup') {
          state.pickup = { lat, lng, address: addr };
          document.getElementById('pickupAddr').textContent = addr;
          document.querySelectorAll('.address-card')[0].classList.add('filled');
          await addMarker('pickup', lat, lng);
        } else {
          state.dropoff = { lat, lng, address: addr };
          document.getElementById('dropoffAddr').textContent = addr;
          document.querySelectorAll('.address-card')[1].classList.add('filled');
          await addMarker('dropoff', lat, lng);
        }

        closePicker();
        validateCurrentStep();

        console.log('✅ Picker confirmation successful');
      } catch (error) {
        console.error('❌ Confirm picker error:', error);
      }
    }

    // Phone formatting
    function formatPhone(input) {
      let val = input.value.replace(/\D/g, '');
      if (!val) return;
      if (val[0] !== '7') val = '7' + val;

      let fmt = '+7';
      if (val.length > 1) fmt += ` (${val.slice(1, 4)}`;
      if (val.length >= 4) fmt += ')';
      if (val.length > 4) fmt += ` ${val.slice(4, 7)}`;
      if (val.length > 7) fmt += `-${val.slice(7, 9)}`;
      if (val.length > 9) fmt += `-${val.slice(9, 11)}`;

      input.value = fmt;
    }

    // Submit order
    async function submitOrder() {
      const submitBtn = document.getElementById('submitBtn');
      const submitText = document.getElementById('submitText');
      const submitLoading = document.getElementById('submitLoading');
      const tg = window.Telegram?.WebApp;

      submitBtn.disabled = true;
      submitText.style.display = 'none';
      submitLoading.style.display = 'block';

      try {
        const formData = new FormData();
        formData.append('from_address', state.pickup.address);
        formData.append('from_lat', state.pickup.lat);
        formData.append('from_lon', state.pickup.lng);
        formData.append('to_address', state.dropoff.address);
        formData.append('to_lat', state.dropoff.lat);
        formData.append('to_lon', state.dropoff.lng);
        formData.append('price', document.getElementById('price').value);
        formData.append('truck_type', state.selectedTruck);
        formData.append('date', document.getElementById('date').value);
        formData.append('time', document.getElementById('time').value);
        formData.append('contact', document.getElementById('phone').value);
        formData.append('comment', document.getElementById('comment').value);

        if (tg?.initDataUnsafe?.user) {
          formData.append('telegram_id', tg.initDataUnsafe.user.id);
          formData.append('telegram_username', tg.initDataUnsafe.user.username || '');
          formData.append('telegram_first_name', tg.initDataUnsafe.user.first_name || '');
          formData.append('telegram_last_name', tg.initDataUnsafe.user.last_name || '');
        }

        const distance = calculateDistance(
          state.pickup.lat, state.pickup.lng,
          state.dropoff.lat, state.dropoff.lng
        );
        formData.append('distance', distance);

        const res = await fetch('/api/delivery-request', { method: 'POST', body: formData });
        const json = await res.json().catch(() => ({ success: false }));

        if (json?.success) {
          state.orderData = {
            pickup: state.pickup,
            dropoff: state.dropoff,
            price: document.getElementById('price').value,
            truck_type: state.selectedTruck,
            contact: document.getElementById('phone').value,
            comment: document.getElementById('comment').value,
            request_id: json.data?.request_id
          };
          showSuccessScreen();
          stopRealtimeGeolocation();
        } else {
          throw new Error(json?.message || 'Request failed');
        }
      } catch (error) {
        const errorMsg = `Error: ${error.message}`;
        const tg = window.Telegram?.WebApp;
        if (tg) tg.showAlert(errorMsg);
        else alert(errorMsg);
      } finally {
        submitBtn.disabled = false;
        submitText.style.display = 'block';
        submitLoading.style.display = 'none';
        validateCurrentStep();
      }
    }

    function showSuccessScreen() {
      document.getElementById('successScreen').classList.add('active');
      setTimeout(() => {
        goToDriverList();
      }, 3000);
    }

    function goToDriverList() {
      const orderData = encodeURIComponent(JSON.stringify(state.orderData));
      window.location.href = `/driver-list?order=${orderData}`;
    }

    function stopRealtimeGeolocation() {
      if (geolocationWatchId) {
        navigator.geolocation.clearWatch(geolocationWatchId);
        geolocationWatchId = null;
      }
      if (mapUpdateInterval) {
        clearInterval(mapUpdateInterval);
        mapUpdateInterval = null;
      }
    }

    function setLang(lang, element) {
      state.lang = lang;
      document.querySelectorAll('.lang-btn').forEach((btn) => btn.classList.remove('active'));
      element.classList.add('active');

      document.querySelectorAll('[data-i18n]').forEach((el) => {
        const key = el.dataset.i18n;
        if (i18n[lang][key]) el.textContent = i18n[lang][key];
      });

      // Update picker instructions if picker is open
      updatePickerInstructions();

      if (lang === 'kz') {
        document.getElementById('gpsText').textContent = 'GPS белсенді';
        document.querySelector('.success-title').textContent = 'Тапсырыс жіберілді!';
        document.querySelector('.success-message').textContent =
          'Қол жетімді жүргізушілерді іздеп жатырмыз...\nБұл бірнеше секундқа созылады';
        document.querySelector('.success-btn').textContent = 'Жүргізушілерді көру';
      } else {
        document.getElementById('gpsText').textContent = 'GPS активен';
        document.querySelector('.success-title').textContent = 'Заказ отправлен!';
        document.querySelector('.success-message').textContent =
          'Ищем доступных водителей...\nЭто займет несколько секунд';
        document.querySelector('.success-btn').textContent = 'Посмотреть водителей';
      }
    }

    // Initialize application with full-screen support
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('🚀 DOM loaded, initializing full-screen app...');
      
      // Update viewport height immediately
      updateViewportHeight();
      
      if (!window.ymaps3) {
        console.error('❌ Yandex Maps v3 failed to load');
        return;
      }
      
      await initMap();
      console.log('✅ Map initialization started');

      const now = new Date();
      document.getElementById('date').valueAsDate = now;
      document.getElementById('time').value = now.toTimeString().slice(0, 5);

      setLang('kz', document.querySelector('.lang-btn.active'));

      // Initialize Telegram WebApp with full-screen support
      if (window.Telegram?.WebApp) {
        const tg = Telegram.WebApp;
        tg.ready();
        tg.expand();
        tg.disableVerticalSwipes();
        
        // Hide status bar for true full-screen experience
        if (tg.setHeaderColor) {
          tg.setHeaderColor('#000000');
        }
        
        // Listen for viewport changes
        tg.onEvent('viewportChanged', updateViewportHeight);
        
        console.log('✅ Telegram WebApp initialized with full-screen support');
      }
    });

    // Handle viewport changes
    window.addEventListener('resize', updateViewportHeight);
    window.addEventListener('orientationchange', () => {
      setTimeout(updateViewportHeight, 100);
    });

    window.addEventListener('beforeunload', () => {
      stopRealtimeGeolocation();
    });

    // Reset panning flag when going to next step
    document.addEventListener('click', (e) => {
      if (e.target.textContent === 'Келесі' && state.currentStep === 2) {
        state.userHasPanned = false;
      }
    });

    // Global function exports
    window.setLang = setLang;
    window.openPicker = openPicker;
    window.closePicker = closePicker;
    window.confirmPicker = confirmPicker;
    window.searchAddress = searchAddress;
    window.selectSuggestion = selectSuggestion;
    window.goToStep = goToStep;
    window.selectTruck = selectTruck;
    window.formatPhone = formatPhone;
    window.submitOrder = submitOrder;
    window.goToDriverList = goToDriverList;
    window.hideSuggestionsDelayed = hideSuggestionsDelayed;
    window.placePinAtCoordinates = placePinAtCoordinates;
    window.updateViewportHeight = updateViewportHeight;
  </script>
</body>
</html>